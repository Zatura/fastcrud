{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"FastCRUD","text":"<p> Powerful CRUD methods and automatic endpoint creation for FastAPI. </p> <p> </p> <p> FastCRUD is a Python package for FastAPI, offering robust async CRUD operations and flexible endpoint creation utilities, streamlined through advanced features like auto-detected join conditions, dynamic sorting, and offset and cursor pagination. </p>"},{"location":"#features","title":"Features","text":"<ul> <li>Fully Async: Leverages Python's async capabilities for non-blocking database operations.</li> <li>SQLAlchemy 2.0: Works with the latest SQLAlchemy version for robust database interactions.</li> <li>Powerful CRUD Functionality: Full suite of efficient CRUD operations with support for joins.</li> <li>Dynamic Query Building: Supports building complex queries dynamically, including filtering, sorting, and pagination.</li> <li>Advanced Join Operations: Facilitates performing SQL joins with other models with automatic join condition detection.</li> <li>Built-in Offset Pagination: Comes with ready-to-use offset pagination.</li> <li>Cursor-based Pagination: Implements efficient pagination for large datasets, ideal for infinite scrolling interfaces.</li> <li>Modular and Extensible: Designed for easy extension and customization to fit your requirements.</li> <li>Auto-generated Endpoints: Streamlines the process of adding CRUD endpoints with custom dependencies and configurations.</li> </ul>"},{"location":"#minimal-example","title":"Minimal Example","text":"<p>Assuming you have your model, schemas and database connection:</p> <pre><code># imports here\n\n# define your model\nclass Item(Base):\n    __tablename__ = 'items'\n    id = Column(Integer, primary_key=True)\n    name = Column(String)\n\n# your schemas\nclass ItemSchema(BaseModel):\n    name: str\n\n# database connection\nDATABASE_URL = \"sqlite+aiosqlite:///./test.db\"\nengine = create_async_engine(DATABASE_URL, echo=True)\nsession = sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)\n</code></pre> <p>Use <code>crud_router</code> and include it in your <code>FastAPI</code> application</p> <pre><code>from fastcrud import FastCRUD, crud_router\n\napp = FastAPI()\n\nitem_router = crud_router(\n    session=session,\n    model=Item,\n    crud=FastCRUD(Item),\n    create_schema=ItemSchema,\n    update_schema=ItemSchema,\n    path=\"/items\",\n    tags=[\"Items\"]\n)\n\napp.include_router(item_router)\n</code></pre> <p>And it's all done, just go to <code>/docs</code> and the crud endpoints are created.</p>"},{"location":"#requirements","title":"Requirements","text":"<p>Before installing FastCRUD, ensure you have the following prerequisites:</p> <ul> <li>Python: Version 3.9 or newer.</li> <li>FastAPI: FastCRUD is built to work with FastAPI, so having FastAPI in your project is essential.</li> <li>SQLAlchemy: Version 2.0 or newer. FastCRUD uses SQLAlchemy for database operations.</li> <li>Pydantic V2: Version 2.0 or newer. FastCRUD leverages Pydantic models for data validation and serialization.</li> <li>SQLAlchemy-Utils: Optional, but recommended for additional SQLAlchemy utilities.</li> </ul>"},{"location":"#installing","title":"Installing","text":"<p>To install, just run:  <pre><code>pip install fastcrud\n</code></pre></p> <p>Or, if using poetry:</p> <pre><code>poetry add fastcrud\n</code></pre>"},{"location":"#usage","title":"Usage","text":"<p>FastCRUD offers two primary ways to use its functionalities: </p> <ol> <li>By using <code>crud_router</code> for automatic endpoint creation.</li> <li>By integrating <code>FastCRUD</code> directly into your FastAPI endpoints for more control.</li> </ol> <p>Below are examples demonstrating both approaches:</p>"},{"location":"#using-crud_router-for-automatic-endpoint-creation","title":"Using crud_router for Automatic Endpoint Creation","text":"<p>Warning</p> <p>For now, your primary column must be named <code>id</code> or automatic endpoint creation will not work.</p> <p>Here's a quick example to get you started:</p>"},{"location":"#define-your-model-and-schema","title":"Define Your Model and Schema","text":"models/item.py<pre><code>from sqlalchemy import Column, Integer, String\nfrom sqlalchemy.orm import DeclarativeBase\nfrom pydantic import BaseModel\n\nclass Base(DeclarativeBase):\n    pass\n\nclass Item(Base):\n    __tablename__ = 'items'\n    id = Column(Integer, primary_key=True)\n    name = Column(String)\n    description = Column(String)\n\nclass ItemCreateSchema(BaseModel):\n    name: str\n    description: str\n\nclass ItemUpdateSchema(BaseModel):\n    name: str\n    description: str\n</code></pre>"},{"location":"#set-up-fastapi-and-fastcrud","title":"Set Up FastAPI and FastCRUD","text":"main.py<pre><code>from fastapi import FastAPI\nfrom fastcrud import FastCRUD, crud_router\nfrom sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy.orm import sessionmaker\n\n# Database setup (Async SQLAlchemy)\nDATABASE_URL = \"sqlite+aiosqlite:///./test.db\"\nengine = create_async_engine(DATABASE_URL, echo=True)\nasync_session = sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)\n\n# FastAPI app\napp = FastAPI()\n\n# CRUD operations setup\ncrud = FastCRUD(Item)\n\n# CRUD router setup\nitem_router = crud_router(\n    session=async_session,\n    model=Item,\n    crud=crud,\n    create_schema=ItemCreateSchema,\n    update_schema=ItemUpdateSchema,\n    path=\"/items\",\n    tags=[\"Items\"]\n)\n\napp.include_router(item_router)\n</code></pre>"},{"location":"#using-fastcrud-in-user-defined-fastapi-endpoints","title":"Using FastCRUD in User-Defined FastAPI Endpoints","text":"<p>For more control over your endpoints, you can use FastCRUD directly within your custom FastAPI route functions. Here's an example:</p> api/v1/item.py<pre><code>from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.ext.asyncio import AsyncSession\nfrom fastcrud import FastCRUD\nfrom yourapp.models import Item\nfrom yourapp.schemas import ItemCreateSchema, ItemUpdateSchema\n\n# Assume async_session is already set up as per the previous example\n\n# Instantiate FastCRUD with your model\nitem_crud = FastCRUD(Item)\n\n@app.post(\"/custom/items/\")\nasync def create_item(item_data: ItemCreateSchema, db: AsyncSession = Depends(async_session)):\n    return await item_crud.create(db, item_data)\n\n@app.get(\"/custom/items/{item_id}\")\nasync def read_item(item_id: int, db: AsyncSession = Depends(async_session)):\n    item = await item_crud.get(db, id=item_id)\n    if not item:\n        raise HTTPException(status_code=404, detail=\"Item not found\")\n    return item\n\n# You can add more routes for update and delete operations in a similar fashion\n</code></pre>"},{"location":"#license","title":"License","text":"<p><code>MIT</code></p>"},{"location":"installing/","title":"Installing","text":""},{"location":"installing/#requirements","title":"Requirements","text":"<p>Before installing FastCRUD, ensure you have the following prerequisites:</p> <ul> <li>Python: Version 3.9 or newer.</li> <li>FastAPI: FastCRUD is built to work with FastAPI, so having FastAPI in your project is essential.</li> <li>SQLAlchemy: Version 2.0 or newer. FastCRUD uses SQLAlchemy for database operations.</li> <li>Pydantic V2: Version 2.0 or newer. FastCRUD leverages Pydantic models for data validation and serialization.</li> <li>SQLAlchemy-Utils: Optional, but recommended for additional SQLAlchemy utilities.</li> </ul>"},{"location":"installing/#installing","title":"Installing","text":"<p>To install, just run:  <pre><code>pip install fastcrud\n</code></pre></p> <p>Or, if using poetry:</p> <pre><code>poetry add fastcrud\n</code></pre>"},{"location":"quick-start/","title":"Quick-Start","text":""},{"location":"quick-start/#minimal-example","title":"Minimal Example","text":"<p>Assuming you have your SQLAlchemy model, Pydantic schemas and database connection, just skip to Using FastCRUD</p>"},{"location":"quick-start/#basic-setup","title":"Basic Setup","text":"<p>Define your SQLAlchemy model</p> setup.py<pre><code>from sqlalchemy import Column, Integer, String\nfrom sqlalchemy.orm import DeclarativeBase, sessionmaker\nfrom sqlalchemy.ext.asyncio import AsyncSession\nfrom pydantic import BaseModel\n\nclass Base(DeclarativeBase):\n    pass\n\nclass Item(Base):\n    __tablename__ = 'items'\n    id = Column(Integer, primary_key=True)\n    name = Column(String)\n\nclass ItemCreateSchema(BaseModel):\n    name: str\n\nDATABASE_URL = \"sqlite+aiosqlite:///./test.db\"\nengine = create_async_engine(DATABASE_URL, echo=True)\nsession = sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)\n</code></pre> <p>Then your Pydantic schemas</p> setup.py<pre><code>from sqlalchemy import Column, Integer, String\nfrom sqlalchemy.orm import DeclarativeBase, sessionmaker\nfrom sqlalchemy.ext.asyncio import AsyncSession\nfrom pydantic import BaseModel\n\nclass Base(DeclarativeBase):\n    pass\n\nclass Item(Base):\n    __tablename__ = 'items'\n    id = Column(Integer, primary_key=True)\n    name = Column(String)\n\nclass ItemCreateSchema(BaseModel):\n    name: str\n\nDATABASE_URL = \"sqlite+aiosqlite:///./test.db\"\nengine = create_async_engine(DATABASE_URL, echo=True)\nsession = sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)\n</code></pre> <p>And, finally, your database connection</p> setup.py<pre><code>from sqlalchemy import Column, Integer, String\nfrom sqlalchemy.orm import DeclarativeBase, sessionmaker\nfrom sqlalchemy.ext.asyncio import AsyncSession\nfrom pydantic import BaseModel\n\nclass Base(DeclarativeBase):\n    pass\n\nclass Item(Base):\n    __tablename__ = 'items'\n    id = Column(Integer, primary_key=True)\n    name = Column(String)\n\nclass ItemCreateSchema(BaseModel):\n    name: str\n\nDATABASE_URL = \"sqlite+aiosqlite:///./test.db\"\nengine = create_async_engine(DATABASE_URL, echo=True)\nsession = sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)\n</code></pre>"},{"location":"quick-start/#using-fastcrud","title":"Using FastCRUD","text":"<p>Use <code>crud_router</code> and include it in your <code>FastAPI</code> application</p> main.py<pre><code>from fastcrud import FastCRUD, crud_router\n\napp = FastAPI()\n\nitem_router = crud_router(\n    session=session,\n    model=Item,\n    crud=FastCRUD(Item),\n    create_schema=ItemSchema,\n    update_schema=ItemSchema,\n    path=\"/items\",\n    tags=[\"Items\"]\n)\n\napp.include_router(item_router)\n</code></pre> <p>And it's all done, just go to <code>/docs</code> and the crud endpoints are created.</p>"},{"location":"advanced/endpoint/","title":"Advanced Use of EndpointCreator","text":"<p>In FastCRUD, the <code>EndpointCreator</code> class simplifies the process of creating standard CRUD endpoints. However, for more advanced use cases, you might want to add custom routes that go beyond the basic CRUD operations. This can be achieved by extending the <code>EndpointCreator</code> class.</p>"},{"location":"advanced/endpoint/#selective-crud-operations","title":"Selective CRUD Operations","text":"<p>You can control which CRUD operations are exposed by using <code>included_methods</code> and <code>deleted_methods</code>. These parameters allow you to specify exactly which CRUD methods should be included or excluded when setting up the router.</p>"},{"location":"advanced/endpoint/#using-included_methods","title":"Using <code>included_methods</code>","text":"<p>Using <code>included_methods</code> you may define exactly the methods you want to be included.</p> <pre><code># Using crud_router with selective CRUD methods\nmy_router = crud_router(\n    session=async_session,\n    model=MyModel,\n    crud=FastCRUD(MyModel),\n    create_schema=CreateMyModel,\n    update_schema=UpdateMyModel,\n    path=\"/mymodel\",\n    tags=[\"MyModel\"],\n    included_methods=[\"create\", \"read\", \"update\"]  # Only these methods will be included\n)\n\napp.include_router(my_router)\n</code></pre>"},{"location":"advanced/endpoint/#using-deleted_methods","title":"Using <code>deleted_methods</code>","text":"<p>Using <code>deleted_methods</code> you define the methods that will not be included.</p> <pre><code># Using crud_router with selective CRUD methods\nmy_router = crud_router(\n    session=async_session,\n    model=MyModel,\n    crud=FastCRUD(MyModel),\n    create_schema=CreateMyModel,\n    update_schema=UpdateMyModel,\n    path=\"/mymodel\",\n    tags=[\"MyModel\"],\n    deleted_methods=[\"update\", \"delete\"]  # All but these methods will be included\n)\n\napp.include_router(my_router)\n</code></pre> <p>Warning</p> <pre><code>If `included_methods` and `deleted_methods` are both provided, a ValueError will be raised.\n</code></pre>"},{"location":"advanced/endpoint/#extending-endpointcreator","title":"Extending EndpointCreator","text":"<p>You can create a subclass of <code>EndpointCreator</code> and override or add new methods to define custom routes. Here's an example:</p>"},{"location":"advanced/endpoint/#creating-a-custom-endpointcreator","title":"Creating a Custom EndpointCreator","text":"<pre><code>from fastcrud import EndpointCreator\n\n# Define the custom EndpointCreator\nclass MyCustomEndpointCreator(EndpointCreator):\n    # Add custom routes or override existing methods\n    def _custom_route(self):\n        async def custom_endpoint():\n            # Custom endpoint logic\n            return {\"message\": \"Custom route\"}\n\n        return custom_endpoint\n\n    # override add_routes_to_router to also add the custom routes\n    def add_routes_to_router(self, ...):\n        # First, add standard CRUD routes if you want them\n        super().add_routes_to_router(...)\n\n        # Now, add custom routes\n        self.router.add_api_route(\n            path=\"/custom\",\n            endpoint=self._custom_route(),\n            methods=[\"GET\"],\n            tags=self.tags,\n            # Other parameters as needed\n        )\n</code></pre>"},{"location":"advanced/endpoint/#adding-custom-routes","title":"Adding custom routes","text":"<pre><code>from fastcrud import EndpointCreator\n\n# Define the custom EndpointCreator\nclass MyCustomEndpointCreator(EndpointCreator):\n    # Add custom routes or override existing methods\n    def _custom_route(self):\n        async def custom_endpoint():\n            # Custom endpoint logic\n            return {\"message\": \"Custom route\"}\n\n        return custom_endpoint\n\n    # override add_routes_to_router to also add the custom routes\n    def add_routes_to_router(self, ...):\n        # First, add standard CRUD routes if you want them\n        super().add_routes_to_router(...)\n\n        # Now, add custom routes\n        self.router.add_api_route(\n            path=\"/custom\",\n            endpoint=self._custom_route(),\n            methods=[\"GET\"],\n            tags=self.tags,\n            # Other parameters as needed\n        )\n</code></pre>"},{"location":"advanced/endpoint/#overriding-add_routes_to_router","title":"Overriding <code>add_routes_to_router</code>","text":"<pre><code>from fastcrud import EndpointCreator\n\n# Define the custom EndpointCreator\nclass MyCustomEndpointCreator(EndpointCreator):\n    # Add custom routes or override existing methods\n    def _custom_route(self):\n        async def custom_endpoint():\n            # Custom endpoint logic\n            return {\"message\": \"Custom route\"}\n\n        return custom_endpoint\n\n    # override add_routes_to_router to also add the custom routes\n    def add_routes_to_router(self, ...):\n        # First, add standard CRUD routes if you want them\n        super().add_routes_to_router(...)\n\n        # Now, add custom routes\n        self.router.add_api_route(\n            path=\"/custom\",\n            endpoint=self._custom_route(),\n            methods=[\"GET\"],\n            tags=self.tags,\n            # Other parameters as needed\n        )\n</code></pre>"},{"location":"advanced/endpoint/#using-the-custom-endpointcreator","title":"Using the Custom EndpointCreator","text":"<pre><code># Assuming MyCustomEndpointCreator was created\n\n...\n\n# Use the custom EndpointCreator with crud_router\nmy_router = crud_router(\n    session=async_session,\n    model=MyModel,\n    crud=FastCRUD(MyModel),\n    create_schema=CreateMyModel,\n    update_schema=UpdateMyModel,\n    endpoint_creator=MyCustomEndpointCreator,\n    path=\"/mymodel\",\n    tags=[\"MyModel\"],\n    included_methods=[\"create\", \"read\", \"update\"]  # Including selective methods\n)\n\napp.include_router(my_router)\n</code></pre>"},{"location":"advanced/endpoint/#conclusion","title":"Conclusion","text":"<p>The <code>EndpointCreator</code> class in FastCRUD offers flexibility and control over CRUD operations and custom endpoint creation. By extending this class or using the <code>included_methods</code> and <code>deleted_methods</code> parameters, you can tailor your API's functionality to your specific requirements, ensuring a more customizable and streamlined experience.</p>"},{"location":"api/crud_router/","title":"CRUD Router API Reference","text":"<p><code>crud_router</code> is a utility function for creating and configuring a FastAPI router with CRUD endpoints for a given model.</p>"},{"location":"api/crud_router/#function-definition","title":"Function Definition","text":"<p>Creates and configures a FastAPI router with CRUD endpoints for a given model.</p> <p>This utility function streamlines the process of setting up a router for CRUD operations, using a custom <code>EndpointCreator</code> if provided, and managing dependency injections as well as selective method inclusions or exclusions.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AsyncSession</code> <p>The SQLAlchemy async session.</p> required <code>model</code> <code>DeclarativeBase</code> <p>The SQLAlchemy model.</p> required <code>crud</code> <code>FastCRUD</code> <p>The FastCRUD instance.</p> required <code>create_schema</code> <code>Type[CreateSchemaType]</code> <p>Pydantic schema for creating an item.</p> required <code>update_schema</code> <code>Type[UpdateSchemaType]</code> <p>Pydantic schema for updating an item.</p> required <code>delete_schema</code> <code>Optional[Type[DeleteSchemaType]]</code> <p>Optional Pydantic schema for deleting an item.</p> <code>None</code> <code>path</code> <code>str</code> <p>Base path for the CRUD endpoints.</p> <code>''</code> <code>tags</code> <code>Optional[List[str]]</code> <p>Optional list of tags for grouping endpoints in the documentation.</p> <code>None</code> <code>include_in_schema</code> <code>bool</code> <p>Whether to include the created endpoints in the OpenAPI schema.</p> <code>True</code> <code>create_deps</code> <code>List[Callable]</code> <p>Optional list of dependency injection functions for the create endpoint.</p> <code>[]</code> <code>read_deps</code> <code>List[Callable]</code> <p>Optional list of dependency injection functions for the read endpoint.</p> <code>[]</code> <code>read_multi_deps</code> <code>List[Callable]</code> <p>Optional list of dependency injection functions for the read multiple items endpoint.</p> <code>[]</code> <code>update_deps</code> <code>List[Callable]</code> <p>Optional list of dependency injection functions for the update endpoint.</p> <code>[]</code> <code>delete_deps</code> <code>List[Callable]</code> <p>Optional list of dependency injection functions for the delete endpoint.</p> <code>[]</code> <code>db_delete_deps</code> <code>List[Callable]</code> <p>Optional list of dependency injection functions for the hard delete endpoint.</p> <code>[]</code> <code>included_methods</code> <code>Optional[list[str]]</code> <p>Optional list of CRUD methods to include. If None, all methods are included.</p> <code>None</code> <code>deleted_methods</code> <code>Optional[list[str]]</code> <p>Optional list of CRUD methods to exclude.</p> <code>None</code> <code>endpoint_creator</code> <code>Optional[Type[EndpointCreator]]</code> <p>Optional custom class derived from EndpointCreator for advanced customization.</p> <code>None</code> <p>Returns:</p> Type Description <code>APIRouter</code> <p>Configured APIRouter instance with the CRUD endpoints.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If both 'included_methods' and 'deleted_methods' are provided.</p> <p>Examples:</p> <p>Basic Setup: <pre><code>router = crud_router(\n    session=async_session,\n    model=MyModel,\n    crud=CRUDMyModel(MyModel),\n    create_schema=CreateMyModelSchema,\n    update_schema=UpdateMyModelSchema,\n    path=\"/mymodel\",\n    tags=[\"MyModel\"]\n)\n</code></pre></p> <p>With Custom Dependencies: <pre><code>def get_current_user(token: str = Depends(oauth2_scheme)):\n    # Implement user retrieval logic\n    return ...\n\nrouter = crud_router(\n    session=async_session,\n    model=UserModel,\n    crud=CRUDUserModel(UserModel),\n    create_schema=CreateUserSchema,\n    update_schema=UpdateUserSchema,\n    read_deps=[get_current_user],\n    update_deps=[get_current_user],\n    path=\"/users\",\n    tags=[\"Users\"]\n)\n</code></pre></p> <p>Adding Delete Endpoints: <pre><code>router = crud_router(\n    session=async_session,\n    model=ProductModel,\n    crud=CRUDProductModel(ProductModel),\n    create_schema=CreateProductSchema,\n    update_schema=UpdateProductSchema,\n    delete_schema=DeleteProductSchema,\n    path=\"/products\",\n    tags=[\"Products\"]\n)\n</code></pre></p> <p>Customizing Path and Tags: <pre><code>router = crud_router(\n    session=async_session,\n    model=OrderModel,\n    crud=CRUDOrderModel(OrderModel),\n    create_schema=CreateOrderSchema,\n    update_schema=UpdateOrderSchema,\n    path=\"/orders\",\n    tags=[\"Orders\", \"Sales\"]\n)\n</code></pre></p> <p>Integrating Multiple Models: <pre><code>product_router = crud_router(\n    session=async_session,\n    model=ProductModel,\n    crud=CRUDProductModel(ProductModel),\n    create_schema=CreateProductSchema,\n    update_schema=UpdateProductSchema,\n    path=\"/products\",\n    tags=[\"Inventory\"]\n)\n\ncustomer_router = crud_router(\n    session=async_session,\n    model=CustomerModel,\n    crud=CRUDCustomerModel(CustomerModel),\n    create_schema=CreateCustomerSchema,\n    update_schema=UpdateCustomerSchema,\n    path=\"/customers\",\n    tags=[\"CRM\"]\n)\n</code></pre></p> <p>With Selective CRUD Methods: <pre><code># Only include 'create' and 'read' methods\nrouter = crud_router(\n    session=async_session,\n    model=MyModel,\n    crud=CRUDMyModel(MyModel),\n    create_schema=CreateMyModel,\n    update_schema=UpdateMyModel,\n    included_methods=[\"create\", \"read\"],\n    path=\"/mymodel\",\n    tags=[\"MyModel\"]\n)\n</code></pre></p> <p>Using a Custom EndpointCreator: <pre><code>class CustomEndpointCreator(EndpointCreator):\n    def _custom_route(self):\n        async def custom_endpoint():\n            # Custom endpoint logic\n            return {\"message\": \"Custom route\"}\n\n        return custom_endpoint\n\n        async def add_routes_to_router(self, ...):\n            # First, add standard CRUD routes\n            super().add_routes_to_router(...)\n\n            # Now, add custom routes\n            self.router.add_api_route(\n                path=\"/custom\",\n                endpoint=self._custom_route(),\n                methods=[\"GET\"],\n                tags=self.tags,\n                # Other parameters as needed\n            )\n\nrouter = crud_router(\n    session=async_session,\n    model=MyModel,\n    crud=CRUDMyModel(MyModel),\n    create_schema=CreateMyModel,\n    update_schema=UpdateMyModel,\n    endpoint_creator=CustomEndpointCreator,\n    path=\"/mymodel\",\n    tags=[\"MyModel\"]\n)\n\napp.include_router(my_router)\n</code></pre></p> Source code in <code>fastcrud/endpoint/crud_router.py</code> <pre><code>def crud_router(\n    session: AsyncSession,\n    model: DeclarativeBase,\n    crud: FastCRUD,\n    create_schema: Type[CreateSchemaType],\n    update_schema: Type[UpdateSchemaType],\n    delete_schema: Optional[Type[DeleteSchemaType]] = None,\n    path: str = \"\",\n    tags: Optional[List[str]] = None,\n    include_in_schema: bool = True,\n    create_deps: List[Callable] = [],\n    read_deps: List[Callable] = [],\n    read_multi_deps: List[Callable] = [],\n    update_deps: List[Callable] = [],\n    delete_deps: List[Callable] = [],\n    db_delete_deps: List[Callable] = [],\n    included_methods: Optional[list[str]] = None,\n    deleted_methods: Optional[list[str]] = None,\n    endpoint_creator: Optional[Type[EndpointCreator]] = None,\n) -&gt; APIRouter:\n    \"\"\"\n    Creates and configures a FastAPI router with CRUD endpoints for a given model.\n\n    This utility function streamlines the process of setting up a router for CRUD operations,\n    using a custom `EndpointCreator` if provided, and managing dependency injections as well\n    as selective method inclusions or exclusions.\n\n    Args:\n        session: The SQLAlchemy async session.\n        model: The SQLAlchemy model.\n        crud: The FastCRUD instance.\n        create_schema: Pydantic schema for creating an item.\n        update_schema: Pydantic schema for updating an item.\n        delete_schema: Optional Pydantic schema for deleting an item.\n        path: Base path for the CRUD endpoints.\n        tags: Optional list of tags for grouping endpoints in the documentation.\n        include_in_schema: Whether to include the created endpoints in the OpenAPI schema.\n        create_deps: Optional list of dependency injection functions for the create endpoint.\n        read_deps: Optional list of dependency injection functions for the read endpoint.\n        read_multi_deps: Optional list of dependency injection functions for the read multiple items endpoint.\n        update_deps: Optional list of dependency injection functions for the update endpoint.\n        delete_deps: Optional list of dependency injection functions for the delete endpoint.\n        db_delete_deps: Optional list of dependency injection functions for the hard delete endpoint.\n        included_methods: Optional list of CRUD methods to include. If None, all methods are included.\n        deleted_methods: Optional list of CRUD methods to exclude.\n        endpoint_creator: Optional custom class derived from EndpointCreator for advanced customization.\n\n    Returns:\n        Configured APIRouter instance with the CRUD endpoints.\n\n    Raises:\n        ValueError: If both 'included_methods' and 'deleted_methods' are provided.\n\n    Examples:\n        Basic Setup:\n        ```python\n        router = crud_router(\n            session=async_session,\n            model=MyModel,\n            crud=CRUDMyModel(MyModel),\n            create_schema=CreateMyModelSchema,\n            update_schema=UpdateMyModelSchema,\n            path=\"/mymodel\",\n            tags=[\"MyModel\"]\n        )\n        ```\n\n        With Custom Dependencies:\n        ```python\n        def get_current_user(token: str = Depends(oauth2_scheme)):\n            # Implement user retrieval logic\n            return ...\n\n        router = crud_router(\n            session=async_session,\n            model=UserModel,\n            crud=CRUDUserModel(UserModel),\n            create_schema=CreateUserSchema,\n            update_schema=UpdateUserSchema,\n            read_deps=[get_current_user],\n            update_deps=[get_current_user],\n            path=\"/users\",\n            tags=[\"Users\"]\n        )\n        ```\n\n        Adding Delete Endpoints:\n        ```python\n        router = crud_router(\n            session=async_session,\n            model=ProductModel,\n            crud=CRUDProductModel(ProductModel),\n            create_schema=CreateProductSchema,\n            update_schema=UpdateProductSchema,\n            delete_schema=DeleteProductSchema,\n            path=\"/products\",\n            tags=[\"Products\"]\n        )\n        ```\n\n        Customizing Path and Tags:\n        ```python\n        router = crud_router(\n            session=async_session,\n            model=OrderModel,\n            crud=CRUDOrderModel(OrderModel),\n            create_schema=CreateOrderSchema,\n            update_schema=UpdateOrderSchema,\n            path=\"/orders\",\n            tags=[\"Orders\", \"Sales\"]\n        )\n        ```\n\n        Integrating Multiple Models:\n        ```python\n        product_router = crud_router(\n            session=async_session,\n            model=ProductModel,\n            crud=CRUDProductModel(ProductModel),\n            create_schema=CreateProductSchema,\n            update_schema=UpdateProductSchema,\n            path=\"/products\",\n            tags=[\"Inventory\"]\n        )\n\n        customer_router = crud_router(\n            session=async_session,\n            model=CustomerModel,\n            crud=CRUDCustomerModel(CustomerModel),\n            create_schema=CreateCustomerSchema,\n            update_schema=UpdateCustomerSchema,\n            path=\"/customers\",\n            tags=[\"CRM\"]\n        )\n        ```\n\n        With Selective CRUD Methods:\n        ```python\n        # Only include 'create' and 'read' methods\n        router = crud_router(\n            session=async_session,\n            model=MyModel,\n            crud=CRUDMyModel(MyModel),\n            create_schema=CreateMyModel,\n            update_schema=UpdateMyModel,\n            included_methods=[\"create\", \"read\"],\n            path=\"/mymodel\",\n            tags=[\"MyModel\"]\n        )\n        ```\n\n        Using a Custom EndpointCreator:\n        ```python\n        class CustomEndpointCreator(EndpointCreator):\n            def _custom_route(self):\n                async def custom_endpoint():\n                    # Custom endpoint logic\n                    return {\"message\": \"Custom route\"}\n\n                return custom_endpoint\n\n                async def add_routes_to_router(self, ...):\n                    # First, add standard CRUD routes\n                    super().add_routes_to_router(...)\n\n                    # Now, add custom routes\n                    self.router.add_api_route(\n                        path=\"/custom\",\n                        endpoint=self._custom_route(),\n                        methods=[\"GET\"],\n                        tags=self.tags,\n                        # Other parameters as needed\n                    )\n\n        router = crud_router(\n            session=async_session,\n            model=MyModel,\n            crud=CRUDMyModel(MyModel),\n            create_schema=CreateMyModel,\n            update_schema=UpdateMyModel,\n            endpoint_creator=CustomEndpointCreator,\n            path=\"/mymodel\",\n            tags=[\"MyModel\"]\n        )\n\n        app.include_router(my_router)\n        ```\n    \"\"\"\n    endpoint_creator_class = endpoint_creator or EndpointCreator\n    endpoint_creator_instance = endpoint_creator_class(\n        session=session,\n        model=model,\n        crud=crud,\n        create_schema=create_schema,\n        update_schema=update_schema,\n        include_in_schema=include_in_schema,\n        delete_schema=delete_schema,\n        path=path,\n        tags=tags,\n    )\n\n    endpoint_creator_instance.add_routes_to_router(\n        create_deps=create_deps,\n        read_deps=read_deps,\n        read_multi_deps=read_multi_deps,\n        update_deps=update_deps,\n        delete_deps=delete_deps,\n        db_delete_deps=db_delete_deps,\n        included_methods=included_methods,\n        deleted_methods=deleted_methods,\n    )\n\n    return endpoint_creator_instance.router\n</code></pre>"},{"location":"api/endpoint_creator/","title":"EndpointCreator API Reference","text":"<p><code>EndpointCreator</code> is a class designed to create and register CRUD endpoints for a FastAPI application. It simplifies the process of adding CRUD (Create, Read, Update, Delete) endpoints to a FastAPI router.</p>"},{"location":"api/endpoint_creator/#class-definition","title":"Class Definition","text":"<p>A class to create and register CRUD endpoints for a FastAPI application.</p> <p>This class simplifies the process of adding create, read, update, and delete (CRUD) endpoints to a FastAPI router. It is initialized with a SQLAlchemy session, model, CRUD operations, and Pydantic schemas, and allows for custom dependency injection for each endpoint. The method assumes 'id' is the primary key for path parameters.</p> <p>Attributes:</p> Name Type Description <code>session</code> <p>The SQLAlchemy async session.</p> <code>model</code> <p>The SQLAlchemy model.</p> <code>crud</code> <p>The CRUD base instance.</p> <code>create_schema</code> <p>Pydantic schema for creating an item.</p> <code>update_schema</code> <p>Pydantic schema for updating an item.</p> <code>delete_schema</code> <p>Optional Pydantic schema for deleting an item.</p> <code>include_in_schema</code> <p>Whether to include the created endpoints in the OpenAPI schema.</p> <code>path</code> <p>Base path for the CRUD endpoints.</p> <code>tags</code> <p>List of tags for grouping endpoints in the documentation.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If both <code>included_methods</code> and <code>deleted_methods</code> are provided.</p> <p>Examples:</p> <p>Basic Setup: <pre><code>from fastapi import FastAPI\nfrom fastcrud import EndpointCreator\n\nfrom myapp.models import MyModel\nfrom myapp.schemas import CreateMyModel, UpdateMyModel\nfrom myapp.crud import CRUDMyModel\nfrom myapp.database import async_session\n\napp = FastAPI()\nmy_model_crud = CRUDMyModel(MyModel)\nendpoint_creator = EndpointCreator(\n    session=async_session,\n    model=MyModel,\n    crud=my_model_crud,\n    create_schema=CreateMyModel,\n    update_schema=UpdateMyModel\n)\nendpoint_creator.add_routes_to_router()\napp.include_router(endpoint_creator.router, prefix=\"/mymodel\")\n</code></pre></p> <p>With Custom Dependencies: <pre><code>from fastapi.security import OAuth2PasswordBearer\n\noauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"token\")\n\ndef get_current_user(token: str = Depends(oauth2_scheme)):\n    return ...\n\nendpoint_creator.add_routes_to_router(\n    read_deps=[get_current_user],\n    update_deps=[get_current_user]\n)\n</code></pre></p> <p>Selective Endpoint Creation (inclusion): <pre><code># Only create 'create' and 'read' endpoints\nendpoint_creator.add_routes_to_router(\n    included_methods=[\"create\", \"read\"]\n)\n</code></pre></p> <p>Selective Endpoint Creation (deletion): <pre><code># Create all but 'update' and 'delete' endpoints\nendpoint_creator.add_routes_to_router(\n    deleted_methods=[\"update\", \"delete\"]\n)\n</code></pre></p> <p>Integrating with Multiple Models: <pre><code># Assuming definitions for OtherModel, CRUDOtherModel, etc.\n\nother_model_crud = CRUDOtherModel(OtherModel)\nother_endpoint_creator = EndpointCreator(\n    session=async_session,\n    model=OtherModel,\n    crud=other_model_crud,\n    create_schema=CreateOtherModel,\n    update_schema=UpdateOtherModel\n)\nother_endpoint_creator.add_routes_to_router()\napp.include_router(other_endpoint_creator.router, prefix=\"/othermodel\")\n</code></pre></p> Source code in <code>fastcrud/endpoint/endpoint_creator.py</code> <pre><code>class EndpointCreator:\n    \"\"\"\n    A class to create and register CRUD endpoints for a FastAPI application.\n\n    This class simplifies the process of adding create, read, update, and delete (CRUD) endpoints\n    to a FastAPI router. It is initialized with a SQLAlchemy session, model, CRUD operations,\n    and Pydantic schemas, and allows for custom dependency injection for each endpoint.\n    The method assumes 'id' is the primary key for path parameters.\n\n    Attributes:\n        session: The SQLAlchemy async session.\n        model: The SQLAlchemy model.\n        crud: The CRUD base instance.\n        create_schema: Pydantic schema for creating an item.\n        update_schema: Pydantic schema for updating an item.\n        delete_schema: Optional Pydantic schema for deleting an item.\n        include_in_schema: Whether to include the created endpoints in the OpenAPI schema.\n        path: Base path for the CRUD endpoints.\n        tags: List of tags for grouping endpoints in the documentation.\n\n    Raises:\n        ValueError: If both `included_methods` and `deleted_methods` are provided.\n\n    Examples:\n        Basic Setup:\n        ```python\n        from fastapi import FastAPI\n        from fastcrud import EndpointCreator\n\n        from myapp.models import MyModel\n        from myapp.schemas import CreateMyModel, UpdateMyModel\n        from myapp.crud import CRUDMyModel\n        from myapp.database import async_session\n\n        app = FastAPI()\n        my_model_crud = CRUDMyModel(MyModel)\n        endpoint_creator = EndpointCreator(\n            session=async_session,\n            model=MyModel,\n            crud=my_model_crud,\n            create_schema=CreateMyModel,\n            update_schema=UpdateMyModel\n        )\n        endpoint_creator.add_routes_to_router()\n        app.include_router(endpoint_creator.router, prefix=\"/mymodel\")\n        ```\n\n        With Custom Dependencies:\n        ```python\n        from fastapi.security import OAuth2PasswordBearer\n\n        oauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"token\")\n\n        def get_current_user(token: str = Depends(oauth2_scheme)):\n            return ...\n\n        endpoint_creator.add_routes_to_router(\n            read_deps=[get_current_user],\n            update_deps=[get_current_user]\n        )\n        ```\n\n        Selective Endpoint Creation (inclusion):\n        ```python\n        # Only create 'create' and 'read' endpoints\n        endpoint_creator.add_routes_to_router(\n            included_methods=[\"create\", \"read\"]\n        )\n        ```\n\n        Selective Endpoint Creation (deletion):\n        ```python\n        # Create all but 'update' and 'delete' endpoints\n        endpoint_creator.add_routes_to_router(\n            deleted_methods=[\"update\", \"delete\"]\n        )\n        ```\n\n        Integrating with Multiple Models:\n        ```python\n        # Assuming definitions for OtherModel, CRUDOtherModel, etc.\n\n        other_model_crud = CRUDOtherModel(OtherModel)\n        other_endpoint_creator = EndpointCreator(\n            session=async_session,\n            model=OtherModel,\n            crud=other_model_crud,\n            create_schema=CreateOtherModel,\n            update_schema=UpdateOtherModel\n        )\n        other_endpoint_creator.add_routes_to_router()\n        app.include_router(other_endpoint_creator.router, prefix=\"/othermodel\")\n        ```\n    \"\"\"\n\n    def __init__(\n        self,\n        session: AsyncSession,\n        model: DeclarativeBase,\n        crud: FastCRUD,\n        create_schema: Type[CreateSchemaType],\n        update_schema: Type[UpdateSchemaType],\n        include_in_schema: bool = True,\n        delete_schema: Optional[Type[DeleteSchemaType]] = None,\n        path: str = \"\",\n        tags: Optional[list[str]] = None,\n    ) -&gt; None:\n        self.primary_key_name = _get_primary_key(model)\n        self.session = session\n        self.crud = crud\n        self.model = model\n        self.create_schema = create_schema\n        self.update_schema = update_schema\n        self.delete_schema = delete_schema\n        self.include_in_schema = include_in_schema\n        self.path = path\n        self.tags = tags or []\n        self.router = APIRouter()\n\n    def _create_item(self):\n        \"\"\"Creates an endpoint for creating items in the database.\"\"\"\n\n        async def endpoint(\n            db: AsyncSession = Depends(self.session),\n            item: self.create_schema = Body(...),  # type: ignore\n        ):\n            unique_columns = _extract_unique_columns(self.model)\n\n            for column in unique_columns:\n                col_name = column.name\n                if hasattr(item, col_name):\n                    value = getattr(item, col_name)\n                    exists = await self.crud.exists(db, **{col_name: value})\n                    if exists:\n                        raise DuplicateValueException(\n                            f\"Value {value} is already registered\"\n                        )\n\n            return await self.crud.create(db, item)\n\n        return endpoint\n\n    def _read_item(self):\n        \"\"\"Creates an endpoint for reading a single item from the database.\"\"\"\n\n        async def endpoint(id: int, db: AsyncSession = Depends(self.session)):\n            item = await self.crud.get(db, id=id)\n            if not item:\n                raise NotFoundException(detail=\"Item not found\")\n            return item\n\n        return endpoint\n\n    def _read_items(self):\n        \"\"\"Creates an endpoint for reading multiple items from the database with optional pagination.\"\"\"\n\n        async def endpoint(\n            db: AsyncSession = Depends(self.session),\n            offset: int = Query(0),\n            limit: int = Query(100),\n        ):\n            return await self.crud.get_multi(db, offset=offset, limit=limit)\n\n        return endpoint\n\n    def _update_item(self):\n        \"\"\"Creates an endpoint for updating an existing item in the database.\"\"\"\n\n        async def endpoint(\n            id: int,\n            item: self.update_schema = Body(...),  # type: ignore\n            db: AsyncSession = Depends(self.session),\n        ):\n            return await self.crud.update(db, item, id=id)\n\n        return endpoint\n\n    def _delete_item(self):\n        \"\"\"Creates an endpoint for deleting an item from the database.\"\"\"\n\n        async def endpoint(id: int, db: AsyncSession = Depends(self.session)):\n            await self.crud.delete(db, id=id)\n            return {\"message\": \"Item deleted successfully\"}\n\n        return endpoint\n\n    def _db_delete(self):\n        \"\"\"\n        Creates an endpoint for hard deleting an item from the database.\n\n        This endpoint is only added if the delete_schema is provided during initialization.\n        The endpoint expects an item ID as a path parameter and uses the provided SQLAlchemy\n        async session to permanently delete the item from the database.\n        \"\"\"\n\n        async def endpoint(id: int, db: AsyncSession = Depends(self.session)):\n            await self.crud.db_delete(db, id=id)\n            return {\"message\": \"Item permanently deleted from the database\"}\n\n        return endpoint\n\n    def add_routes_to_router(\n        self,\n        create_deps: list[Callable] = [],\n        read_deps: list[Callable] = [],\n        read_multi_deps: list[Callable] = [],\n        update_deps: list[Callable] = [],\n        delete_deps: list[Callable] = [],\n        db_delete_deps: list[Callable] = [],\n        included_methods: Optional[list[str]] = None,\n        deleted_methods: Optional[list[str]] = None,\n    ):\n        \"\"\"\n        Adds CRUD operation routes to the FastAPI router with specified dependencies for each type of operation.\n\n        This method registers routes for create, read, update, and delete operations with the FastAPI router,\n        allowing for custom dependency injection for each type of operation.\n\n        Args:\n            create_deps: List of dependency injection functions for the create endpoint.\n            read_deps: List of dependency injection functions for the read endpoint.\n            read_multi_deps: List of dependency injection functions for the read multiple items endpoint.\n            update_deps: List of dependency injection functions for the update endpoint.\n            delete_deps: List of dependency injection functions for the delete endpoint.\n            db_delete_deps: List of dependency injection functions for the hard delete endpoint.\n            included_methods: Optional list of methods to include. Defaults to all CRUD methods.\n            deleted_methods: Optional list of methods to exclude. Defaults to None.\n\n        Raises:\n            ValueError: If both `included_methods` and `deleted_methods` are provided.\n\n        Examples:\n            Selective Endpoint Creation:\n            ```python\n            # Only create 'create' and 'read' endpoints\n            endpoint_creator.add_routes_to_router(\n                included_methods=[\"create\", \"read\"]\n            )\n            ```\n\n            Excluding Specific Endpoints:\n            ```python\n            # Create all endpoints except 'delete' and 'db_delete'\n            endpoint_creator.add_routes_to_router(\n                deleted_methods=[\"delete\", \"db_delete\"]\n            )\n            ```\n\n            With Custom Dependencies and Selective Endpoints:\n            ```python\n            def get_current_user(...):\n                ...\n\n            # Create only 'read' and 'update' endpoints with custom dependencies\n            endpoint_creator.add_routes_to_router(\n                read_deps=[get_current_user],\n                update_deps=[get_current_user],\n                included_methods=[\"read\", \"update\"]\n            )\n            ```\n\n        Note:\n            This method should be called to register the endpoints with the FastAPI application.\n            If 'delete_schema' is provided, a hard delete endpoint is also registered.\n            This method assumes 'id' is the primary key for path parameters.\n        \"\"\"\n        if (included_methods is not None) and (deleted_methods is not None):\n            raise ValueError(\n                \"Cannot use both 'included_methods' and 'deleted_methods' simultaneously.\"\n            )\n\n        if included_methods is None:\n            included_methods = [\n                \"create\",\n                \"read\",\n                \"read_multi\",\n                \"update\",\n                \"delete\",\n                \"db_delete\",\n            ]\n        else:\n            try:\n                included_methods = CRUDMethods(\n                    valid_methods=included_methods\n                ).valid_methods\n            except ValidationError as e:\n                raise ValueError(f\"Invalid CRUD methods in included_methods: {e}\")\n\n        if deleted_methods is None:\n            deleted_methods = []\n        else:\n            try:\n                deleted_methods = CRUDMethods(\n                    valid_methods=deleted_methods\n                ).valid_methods\n            except ValidationError as e:\n                raise ValueError(f\"Invalid CRUD methods in deleted_methods: {e}\")\n\n        delete_description = \"Delete a\"\n        if self.delete_schema:\n            delete_description = \"Soft delete a\"\n\n        if (\"create\" in included_methods) and (\"create\" not in deleted_methods):\n            self.router.add_api_route(\n                f\"{self.path}/create\",\n                self._create_item(),\n                methods=[\"POST\"],\n                include_in_schema=self.include_in_schema,\n                tags=self.tags,\n                dependencies=create_deps,\n                description=f\"Create a new {self.model.__name__} row in the database.\",\n            )\n\n        if (\"read\" in included_methods) and (\"read\" not in deleted_methods):\n            self.router.add_api_route(\n                f\"{self.path}/get/{{{self.primary_key_name}}}\",\n                self._read_item(),\n                methods=[\"GET\"],\n                include_in_schema=self.include_in_schema,\n                tags=self.tags,\n                dependencies=read_deps,\n                description=f\"Read a single {self.model.__name__} row from the database by its primary key: {self.primary_key_name}.\",\n            )\n\n        if (\"read_multi\" in included_methods) and (\"read_multi\" not in deleted_methods):\n            self.router.add_api_route(\n                f\"{self.path}/get_multi\",\n                self._read_items(),\n                methods=[\"GET\"],\n                include_in_schema=self.include_in_schema,\n                tags=self.tags,\n                dependencies=read_multi_deps,\n                description=f\"Read multiple {self.model.__name__} rows from the database with optional pagination.\",\n            )\n\n        if (\"update\" in included_methods) and (\"update\" not in deleted_methods):\n            self.router.add_api_route(\n                f\"{self.path}/update/{{{self.primary_key_name}}}\",\n                self._update_item(),\n                methods=[\"PATCH\"],\n                include_in_schema=self.include_in_schema,\n                tags=self.tags,\n                dependencies=update_deps,\n                description=f\"Update an existing {self.model.__name__} row in the database by its primary key: {self.primary_key_name}.\",\n            )\n\n        if (\"delete\" in included_methods) and (\"delete\" not in deleted_methods):\n            self.router.add_api_route(\n                f\"{self.path}/delete/{{{self.primary_key_name}}}\",\n                self._delete_item(),\n                methods=[\"DELETE\"],\n                include_in_schema=self.include_in_schema,\n                tags=self.tags,\n                dependencies=delete_deps,\n                description=f\"{delete_description} {self.model.__name__} row from the database by its primary key: {self.primary_key_name}.\",\n            )\n\n        if (\n            (\"db_delete\" in included_methods)\n            and (\"db_delete\" not in deleted_methods)\n            and self.delete_schema\n        ):\n            self.router.add_api_route(\n                f\"{self.path}/db_delete/{{{self.primary_key_name}}}\",\n                self._db_delete(),\n                methods=[\"DELETE\"],\n                include_in_schema=self.include_in_schema,\n                tags=self.tags,\n                dependencies=db_delete_deps,\n                description=f\"Permanently delete a {self.model.__name__} row from the database by its primary key: {self.primary_key_name}.\",\n            )\n\n    def add_custom_route(\n        self,\n        endpoint: Callable,\n        methods: list[str],\n        path: Optional[str] = None,\n        dependencies: Optional[list[Callable]] = None,\n        include_in_schema: bool = True,\n        tags: Optional[list[str]] = None,\n        summary: Optional[str] = None,\n        description: Optional[str] = None,\n        response_description: Optional[str] = None,\n    ) -&gt; None:\n        \"\"\"\n        Adds a custom route to the FastAPI router.\n\n        Args:\n            path: URL path for the custom route.\n            endpoint: The endpoint function to execute when the route is called.\n            methods: A list of HTTP methods for the route (e.g., ['GET', 'POST']).\n            dependencies: A list of dependency injection functions for the route.\n            include_in_schema: Whether to include this route in the OpenAPI schema.\n            tags: Tags for grouping and categorizing the route in documentation.\n            summary: A short summary of the route, for documentation.\n            description: A detailed description of the route, for documentation.\n            response_description: A description of the response, for documentation.\n\n        Example:\n            ```python\n            async def custom_endpoint(foo: int, bar: str):\n                # custom logic here\n                return {\"foo\": foo, \"bar\": bar}\n\n            endpoint_creator.add_custom_route(\n                endpoint=custom_endpoint,\n                path=\"/custom\",\n                methods=[\"GET\"],\n                tags=[\"custom\"],\n                summary=\"Custom Endpoint\",\n                description=\"This is a custom endpoint.\"\n            )\n            ```\n        \"\"\"\n        path = path or self.path\n        full_path = f\"{self.path}{path}\"\n        self.router.add_api_route(\n            path=full_path,\n            endpoint=endpoint,\n            methods=methods,\n            dependencies=dependencies or [],\n            include_in_schema=include_in_schema,\n            tags=tags or self.tags,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n        )\n</code></pre>"},{"location":"api/endpoint_creator/#fastcrud.EndpointCreator.add_custom_route","title":"<code>add_custom_route(endpoint, methods, path=None, dependencies=None, include_in_schema=True, tags=None, summary=None, description=None, response_description=None)</code>","text":"<p>Adds a custom route to the FastAPI router.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Optional[str]</code> <p>URL path for the custom route.</p> <code>None</code> <code>endpoint</code> <code>Callable</code> <p>The endpoint function to execute when the route is called.</p> required <code>methods</code> <code>list[str]</code> <p>A list of HTTP methods for the route (e.g., ['GET', 'POST']).</p> required <code>dependencies</code> <code>Optional[list[Callable]]</code> <p>A list of dependency injection functions for the route.</p> <code>None</code> <code>include_in_schema</code> <code>bool</code> <p>Whether to include this route in the OpenAPI schema.</p> <code>True</code> <code>tags</code> <code>Optional[list[str]]</code> <p>Tags for grouping and categorizing the route in documentation.</p> <code>None</code> <code>summary</code> <code>Optional[str]</code> <p>A short summary of the route, for documentation.</p> <code>None</code> <code>description</code> <code>Optional[str]</code> <p>A detailed description of the route, for documentation.</p> <code>None</code> <code>response_description</code> <code>Optional[str]</code> <p>A description of the response, for documentation.</p> <code>None</code> Example <pre><code>async def custom_endpoint(foo: int, bar: str):\n    # custom logic here\n    return {\"foo\": foo, \"bar\": bar}\n\nendpoint_creator.add_custom_route(\n    endpoint=custom_endpoint,\n    path=\"/custom\",\n    methods=[\"GET\"],\n    tags=[\"custom\"],\n    summary=\"Custom Endpoint\",\n    description=\"This is a custom endpoint.\"\n)\n</code></pre> Source code in <code>fastcrud/endpoint/endpoint_creator.py</code> <pre><code>def add_custom_route(\n    self,\n    endpoint: Callable,\n    methods: list[str],\n    path: Optional[str] = None,\n    dependencies: Optional[list[Callable]] = None,\n    include_in_schema: bool = True,\n    tags: Optional[list[str]] = None,\n    summary: Optional[str] = None,\n    description: Optional[str] = None,\n    response_description: Optional[str] = None,\n) -&gt; None:\n    \"\"\"\n    Adds a custom route to the FastAPI router.\n\n    Args:\n        path: URL path for the custom route.\n        endpoint: The endpoint function to execute when the route is called.\n        methods: A list of HTTP methods for the route (e.g., ['GET', 'POST']).\n        dependencies: A list of dependency injection functions for the route.\n        include_in_schema: Whether to include this route in the OpenAPI schema.\n        tags: Tags for grouping and categorizing the route in documentation.\n        summary: A short summary of the route, for documentation.\n        description: A detailed description of the route, for documentation.\n        response_description: A description of the response, for documentation.\n\n    Example:\n        ```python\n        async def custom_endpoint(foo: int, bar: str):\n            # custom logic here\n            return {\"foo\": foo, \"bar\": bar}\n\n        endpoint_creator.add_custom_route(\n            endpoint=custom_endpoint,\n            path=\"/custom\",\n            methods=[\"GET\"],\n            tags=[\"custom\"],\n            summary=\"Custom Endpoint\",\n            description=\"This is a custom endpoint.\"\n        )\n        ```\n    \"\"\"\n    path = path or self.path\n    full_path = f\"{self.path}{path}\"\n    self.router.add_api_route(\n        path=full_path,\n        endpoint=endpoint,\n        methods=methods,\n        dependencies=dependencies or [],\n        include_in_schema=include_in_schema,\n        tags=tags or self.tags,\n        summary=summary,\n        description=description,\n        response_description=response_description,\n    )\n</code></pre>"},{"location":"api/endpoint_creator/#fastcrud.EndpointCreator.add_routes_to_router","title":"<code>add_routes_to_router(create_deps=[], read_deps=[], read_multi_deps=[], update_deps=[], delete_deps=[], db_delete_deps=[], included_methods=None, deleted_methods=None)</code>","text":"<p>Adds CRUD operation routes to the FastAPI router with specified dependencies for each type of operation.</p> <p>This method registers routes for create, read, update, and delete operations with the FastAPI router, allowing for custom dependency injection for each type of operation.</p> <p>Parameters:</p> Name Type Description Default <code>create_deps</code> <code>list[Callable]</code> <p>List of dependency injection functions for the create endpoint.</p> <code>[]</code> <code>read_deps</code> <code>list[Callable]</code> <p>List of dependency injection functions for the read endpoint.</p> <code>[]</code> <code>read_multi_deps</code> <code>list[Callable]</code> <p>List of dependency injection functions for the read multiple items endpoint.</p> <code>[]</code> <code>update_deps</code> <code>list[Callable]</code> <p>List of dependency injection functions for the update endpoint.</p> <code>[]</code> <code>delete_deps</code> <code>list[Callable]</code> <p>List of dependency injection functions for the delete endpoint.</p> <code>[]</code> <code>db_delete_deps</code> <code>list[Callable]</code> <p>List of dependency injection functions for the hard delete endpoint.</p> <code>[]</code> <code>included_methods</code> <code>Optional[list[str]]</code> <p>Optional list of methods to include. Defaults to all CRUD methods.</p> <code>None</code> <code>deleted_methods</code> <code>Optional[list[str]]</code> <p>Optional list of methods to exclude. Defaults to None.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If both <code>included_methods</code> and <code>deleted_methods</code> are provided.</p> <p>Examples:</p> <p>Selective Endpoint Creation: <pre><code># Only create 'create' and 'read' endpoints\nendpoint_creator.add_routes_to_router(\n    included_methods=[\"create\", \"read\"]\n)\n</code></pre></p> <p>Excluding Specific Endpoints: <pre><code># Create all endpoints except 'delete' and 'db_delete'\nendpoint_creator.add_routes_to_router(\n    deleted_methods=[\"delete\", \"db_delete\"]\n)\n</code></pre></p> <p>With Custom Dependencies and Selective Endpoints: <pre><code>def get_current_user(...):\n    ...\n\n# Create only 'read' and 'update' endpoints with custom dependencies\nendpoint_creator.add_routes_to_router(\n    read_deps=[get_current_user],\n    update_deps=[get_current_user],\n    included_methods=[\"read\", \"update\"]\n)\n</code></pre></p> Note <p>This method should be called to register the endpoints with the FastAPI application. If 'delete_schema' is provided, a hard delete endpoint is also registered. This method assumes 'id' is the primary key for path parameters.</p> Source code in <code>fastcrud/endpoint/endpoint_creator.py</code> <pre><code>def add_routes_to_router(\n    self,\n    create_deps: list[Callable] = [],\n    read_deps: list[Callable] = [],\n    read_multi_deps: list[Callable] = [],\n    update_deps: list[Callable] = [],\n    delete_deps: list[Callable] = [],\n    db_delete_deps: list[Callable] = [],\n    included_methods: Optional[list[str]] = None,\n    deleted_methods: Optional[list[str]] = None,\n):\n    \"\"\"\n    Adds CRUD operation routes to the FastAPI router with specified dependencies for each type of operation.\n\n    This method registers routes for create, read, update, and delete operations with the FastAPI router,\n    allowing for custom dependency injection for each type of operation.\n\n    Args:\n        create_deps: List of dependency injection functions for the create endpoint.\n        read_deps: List of dependency injection functions for the read endpoint.\n        read_multi_deps: List of dependency injection functions for the read multiple items endpoint.\n        update_deps: List of dependency injection functions for the update endpoint.\n        delete_deps: List of dependency injection functions for the delete endpoint.\n        db_delete_deps: List of dependency injection functions for the hard delete endpoint.\n        included_methods: Optional list of methods to include. Defaults to all CRUD methods.\n        deleted_methods: Optional list of methods to exclude. Defaults to None.\n\n    Raises:\n        ValueError: If both `included_methods` and `deleted_methods` are provided.\n\n    Examples:\n        Selective Endpoint Creation:\n        ```python\n        # Only create 'create' and 'read' endpoints\n        endpoint_creator.add_routes_to_router(\n            included_methods=[\"create\", \"read\"]\n        )\n        ```\n\n        Excluding Specific Endpoints:\n        ```python\n        # Create all endpoints except 'delete' and 'db_delete'\n        endpoint_creator.add_routes_to_router(\n            deleted_methods=[\"delete\", \"db_delete\"]\n        )\n        ```\n\n        With Custom Dependencies and Selective Endpoints:\n        ```python\n        def get_current_user(...):\n            ...\n\n        # Create only 'read' and 'update' endpoints with custom dependencies\n        endpoint_creator.add_routes_to_router(\n            read_deps=[get_current_user],\n            update_deps=[get_current_user],\n            included_methods=[\"read\", \"update\"]\n        )\n        ```\n\n    Note:\n        This method should be called to register the endpoints with the FastAPI application.\n        If 'delete_schema' is provided, a hard delete endpoint is also registered.\n        This method assumes 'id' is the primary key for path parameters.\n    \"\"\"\n    if (included_methods is not None) and (deleted_methods is not None):\n        raise ValueError(\n            \"Cannot use both 'included_methods' and 'deleted_methods' simultaneously.\"\n        )\n\n    if included_methods is None:\n        included_methods = [\n            \"create\",\n            \"read\",\n            \"read_multi\",\n            \"update\",\n            \"delete\",\n            \"db_delete\",\n        ]\n    else:\n        try:\n            included_methods = CRUDMethods(\n                valid_methods=included_methods\n            ).valid_methods\n        except ValidationError as e:\n            raise ValueError(f\"Invalid CRUD methods in included_methods: {e}\")\n\n    if deleted_methods is None:\n        deleted_methods = []\n    else:\n        try:\n            deleted_methods = CRUDMethods(\n                valid_methods=deleted_methods\n            ).valid_methods\n        except ValidationError as e:\n            raise ValueError(f\"Invalid CRUD methods in deleted_methods: {e}\")\n\n    delete_description = \"Delete a\"\n    if self.delete_schema:\n        delete_description = \"Soft delete a\"\n\n    if (\"create\" in included_methods) and (\"create\" not in deleted_methods):\n        self.router.add_api_route(\n            f\"{self.path}/create\",\n            self._create_item(),\n            methods=[\"POST\"],\n            include_in_schema=self.include_in_schema,\n            tags=self.tags,\n            dependencies=create_deps,\n            description=f\"Create a new {self.model.__name__} row in the database.\",\n        )\n\n    if (\"read\" in included_methods) and (\"read\" not in deleted_methods):\n        self.router.add_api_route(\n            f\"{self.path}/get/{{{self.primary_key_name}}}\",\n            self._read_item(),\n            methods=[\"GET\"],\n            include_in_schema=self.include_in_schema,\n            tags=self.tags,\n            dependencies=read_deps,\n            description=f\"Read a single {self.model.__name__} row from the database by its primary key: {self.primary_key_name}.\",\n        )\n\n    if (\"read_multi\" in included_methods) and (\"read_multi\" not in deleted_methods):\n        self.router.add_api_route(\n            f\"{self.path}/get_multi\",\n            self._read_items(),\n            methods=[\"GET\"],\n            include_in_schema=self.include_in_schema,\n            tags=self.tags,\n            dependencies=read_multi_deps,\n            description=f\"Read multiple {self.model.__name__} rows from the database with optional pagination.\",\n        )\n\n    if (\"update\" in included_methods) and (\"update\" not in deleted_methods):\n        self.router.add_api_route(\n            f\"{self.path}/update/{{{self.primary_key_name}}}\",\n            self._update_item(),\n            methods=[\"PATCH\"],\n            include_in_schema=self.include_in_schema,\n            tags=self.tags,\n            dependencies=update_deps,\n            description=f\"Update an existing {self.model.__name__} row in the database by its primary key: {self.primary_key_name}.\",\n        )\n\n    if (\"delete\" in included_methods) and (\"delete\" not in deleted_methods):\n        self.router.add_api_route(\n            f\"{self.path}/delete/{{{self.primary_key_name}}}\",\n            self._delete_item(),\n            methods=[\"DELETE\"],\n            include_in_schema=self.include_in_schema,\n            tags=self.tags,\n            dependencies=delete_deps,\n            description=f\"{delete_description} {self.model.__name__} row from the database by its primary key: {self.primary_key_name}.\",\n        )\n\n    if (\n        (\"db_delete\" in included_methods)\n        and (\"db_delete\" not in deleted_methods)\n        and self.delete_schema\n    ):\n        self.router.add_api_route(\n            f\"{self.path}/db_delete/{{{self.primary_key_name}}}\",\n            self._db_delete(),\n            methods=[\"DELETE\"],\n            include_in_schema=self.include_in_schema,\n            tags=self.tags,\n            dependencies=db_delete_deps,\n            description=f\"Permanently delete a {self.model.__name__} row from the database by its primary key: {self.primary_key_name}.\",\n        )\n</code></pre>"},{"location":"api/fastcrud/","title":"FastCRUD API Reference","text":"<p><code>FastCRUD</code> is a base class for CRUD operations on a model, utilizing Pydantic schemas for data validation and serialization.</p>"},{"location":"api/fastcrud/#class-definition","title":"Class Definition","text":"<p>             Bases: <code>Generic[ModelType, CreateSchemaType, UpdateSchemaType, UpdateSchemaInternalType, DeleteSchemaType]</code></p> <p>Base class for CRUD operations on a model.</p> <p>This class provides a set of methods for create, read, update, and delete operations on a given SQLAlchemy model, utilizing Pydantic schemas for data validation and serialization.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>type[ModelType]</code> <p>The SQLAlchemy model type.</p> required <p>Methods:</p> Name Description <code>create</code> <p>AsyncSession, object: CreateSchemaType) -&gt; ModelType: Creates a new record in the database. The 'object' parameter is a Pydantic schema containing the data to be saved.</p> <code>get</code> <p>AsyncSession, schema_to_select: Optional[Union[type[BaseModel], list]] = None, **kwargs: Any) -&gt; Optional[dict]: Retrieves a single record based on filters. You can specify a Pydantic schema to select specific columns, and pass filter conditions as keyword arguments.</p> <code>exists</code> <p>AsyncSession, **kwargs: Any) -&gt; bool: Checks if a record exists based on the provided filters. Returns True if the record exists, False otherwise.</p> <code>count</code> <p>AsyncSession, **kwargs: Any) -&gt; int: Counts the number of records matching the provided filters. Useful for pagination and analytics.</p> <code>get_multi</code> <p>AsyncSession, offset: int = 0, limit: int = 100, schema_to_select: Optional[type[BaseModel]] = None, sort_columns: Optional[Union[str, list[str]]] = None, sort_orders: Optional[Union[str, list[str]]] = None, return_as_model: bool = False, **kwargs: Any) -&gt; dict[str, Any]: Fetches multiple records with optional sorting, pagination, and model conversion. Filters, sorting, and pagination parameters can be provided.</p> <code>get_joined</code> <p>AsyncSession, join_model: type[ModelType], join_prefix: Optional[str] = None, join_on: Optional[Union[Join, None]] = None, schema_to_select: Optional[Union[type[BaseModel], list]] = None, join_schema_to_select: Optional[Union[type[BaseModel], list]] = None, join_type: str = \"left\", **kwargs: Any) -&gt; Optional[dict[str, Any]]: Performs a join operation with another model. Supports custom join conditions and selection of specific columns using Pydantic schemas.</p> <code>get_multi_joined</code> <p>AsyncSession, join_model: type[ModelType], join_prefix: Optional[str] = None, join_on: Optional[Join] = None, schema_to_select: Optional[type[BaseModel]] = None, join_schema_to_select: Optional[type[BaseModel]] = None, join_type: str = \"left\", offset: int = 0, limit: int = 100, sort_columns: Optional[Union[str, list[str]]] = None, sort_orders: Optional[Union[str, list[str]]] = None, return_as_model: bool = False, **kwargs: Any) -&gt; dict[str, Any]: Similar to 'get_joined', but for fetching multiple records. Offers pagination and sorting functionalities for the joined tables.</p> <code>get_multi_by_cursor</code> <p>AsyncSession, cursor: Any = None, limit: int = 100, schema_to_select: Optional[type[BaseModel]] = None, sort_column: str = \"id\", sort_order: str = \"asc\", **kwargs: Any) -&gt; dict[str, Any]: Implements cursor-based pagination for fetching records. Useful for large datasets and infinite scrolling features.</p> <code>update</code> <p>AsyncSession, object: Union[UpdateSchemaType, dict[str, Any]], **kwargs: Any) -&gt; None: Updates an existing record. The 'object' can be a Pydantic schema or dictionary containing update data.</p> <code>db_delete</code> <p>AsyncSession, **kwargs: Any) -&gt; None: Hard deletes a record from the database based on provided filters.</p> <code>delete</code> <p>AsyncSession, db_row: Optional[Row] = None, **kwargs: Any) -&gt; None: Soft deletes a record if it has an \"is_deleted\" attribute; otherwise, performs a hard delete. Filters or an existing database row can be provided for deletion.</p> <p>Examples:</p>"},{"location":"api/fastcrud/#fastcrud.FastCRUD--example-1-basic-usage","title":"Example 1: Basic Usage","text":"<p>Create a FastCRUD instance for a User model and perform basic CRUD operations. <pre><code>user_crud = FastCRUD(User, UserCreateSchema, UserUpdateSchema)\nasync with db_session() as db:\n    # Create a new user\n    new_user = await user_crud.create(db, UserCreateSchema(name=\"Alice\"))\n    # Read a user\n    user = await user_crud.get(db, id=new_user.id)\n    # Update a user\n    await user_crud.update(db, UserUpdateSchema(email=\"alice@example.com\"), id=new_user.id)\n    # Delete a user\n    await user_crud.delete(db, id=new_user.id)\n</code></pre></p>"},{"location":"api/fastcrud/#fastcrud.FastCRUD--example-2-advanced-filtering-and-pagination","title":"Example 2: Advanced Filtering and Pagination","text":"<p>Use advanced filtering, sorting, and pagination for fetching records. <pre><code>product_crud = FastCRUD(Product, ProductCreateSchema)\nasync with db_session() as db:\n    products = await product_crud.get_multi(\n        db, offset=0, limit=10, sort_columns=['price'], sort_orders=['asc']\n    )\n</code></pre></p>"},{"location":"api/fastcrud/#fastcrud.FastCRUD--example-3-join-operations-with-custom-schemas","title":"Example 3: Join Operations with Custom Schemas","text":"<p>Perform join operations between two models using custom schemas for selection. <pre><code>order_crud = FastCRUD(Order, OrderCreateSchema, join_model=Product)\nasync with db_session() as db:\n    orders = await order_crud.get_multi_joined(\n        db, offset=0, limit=5, schema_to_select=OrderReadSchema, join_schema_to_select=ProductReadSchema\n    )\n</code></pre></p>"},{"location":"api/fastcrud/#fastcrud.FastCRUD--example-4-cursor-pagination","title":"Example 4: Cursor Pagination","text":"<p>Implement cursor-based pagination for efficient data retrieval in large datasets. <pre><code>comment_crud = FastCRUD(Comment, CommentCreateSchema)\nasync with db_session() as db:\n    first_page = await comment_crud.get_multi_by_cursor(db, limit=10)\n    next_cursor = first_page['next_cursor']\n    second_page = await comment_crud.get_multi_by_cursor(db, cursor=next_cursor, limit=10)\n</code></pre></p>"},{"location":"api/fastcrud/#fastcrud.FastCRUD--example-5-dynamic-filtering-and-counting","title":"Example 5: Dynamic Filtering and Counting","text":"<p>Dynamically filter records based on various criteria and count the results. <pre><code>task_crud = FastCRUD(Task, TaskCreateSchema)\nasync with db_session() as db:\n    completed_tasks = await task_crud.get_multi(db, status='completed')\n    high_priority_task_count = await task_crud.count(db, priority='high')\n</code></pre></p> Source code in <code>fastcrud/crud/fast_crud.py</code> <pre><code>class FastCRUD(\n    Generic[\n        ModelType,\n        CreateSchemaType,\n        UpdateSchemaType,\n        UpdateSchemaInternalType,\n        DeleteSchemaType,\n    ]\n):\n    \"\"\"\n    Base class for CRUD operations on a model.\n\n    This class provides a set of methods for create, read, update, and delete operations on a given SQLAlchemy model,\n    utilizing Pydantic schemas for data validation and serialization.\n\n    Args:\n        model: The SQLAlchemy model type.\n\n    Methods:\n        create(db: AsyncSession, object: CreateSchemaType) -&gt; ModelType:\n            Creates a new record in the database. The 'object' parameter is a Pydantic schema\n            containing the data to be saved.\n\n        get(db: AsyncSession, schema_to_select: Optional[Union[type[BaseModel], list]] = None, **kwargs: Any) -&gt; Optional[dict]:\n            Retrieves a single record based on filters. You can specify a Pydantic schema to\n            select specific columns, and pass filter conditions as keyword arguments.\n\n        exists(db: AsyncSession, **kwargs: Any) -&gt; bool:\n            Checks if a record exists based on the provided filters. Returns True if the record\n            exists, False otherwise.\n\n        count(db: AsyncSession, **kwargs: Any) -&gt; int:\n            Counts the number of records matching the provided filters. Useful for pagination\n            and analytics.\n\n        get_multi(db: AsyncSession, offset: int = 0, limit: int = 100, schema_to_select: Optional[type[BaseModel]] = None, sort_columns: Optional[Union[str, list[str]]] = None, sort_orders: Optional[Union[str, list[str]]] = None, return_as_model: bool = False, **kwargs: Any) -&gt; dict[str, Any]:\n            Fetches multiple records with optional sorting, pagination, and model conversion.\n            Filters, sorting, and pagination parameters can be provided.\n\n        get_joined(db: AsyncSession, join_model: type[ModelType], join_prefix: Optional[str] = None, join_on: Optional[Union[Join, None]] = None, schema_to_select: Optional[Union[type[BaseModel], list]] = None, join_schema_to_select: Optional[Union[type[BaseModel], list]] = None, join_type: str = \"left\", **kwargs: Any) -&gt; Optional[dict[str, Any]]:\n            Performs a join operation with another model. Supports custom join conditions and\n            selection of specific columns using Pydantic schemas.\n\n        get_multi_joined(db: AsyncSession, join_model: type[ModelType], join_prefix: Optional[str] = None, join_on: Optional[Join] = None, schema_to_select: Optional[type[BaseModel]] = None, join_schema_to_select: Optional[type[BaseModel]] = None, join_type: str = \"left\", offset: int = 0, limit: int = 100, sort_columns: Optional[Union[str, list[str]]] = None, sort_orders: Optional[Union[str, list[str]]] = None, return_as_model: bool = False, **kwargs: Any) -&gt; dict[str, Any]:\n            Similar to 'get_joined', but for fetching multiple records. Offers pagination and\n            sorting functionalities for the joined tables.\n\n        get_multi_by_cursor(db: AsyncSession, cursor: Any = None, limit: int = 100, schema_to_select: Optional[type[BaseModel]] = None, sort_column: str = \"id\", sort_order: str = \"asc\", **kwargs: Any) -&gt; dict[str, Any]:\n            Implements cursor-based pagination for fetching records. Useful for large datasets\n            and infinite scrolling features.\n\n        update(db: AsyncSession, object: Union[UpdateSchemaType, dict[str, Any]], **kwargs: Any) -&gt; None:\n            Updates an existing record. The 'object' can be a Pydantic schema or dictionary\n            containing update data.\n\n        db_delete(db: AsyncSession, **kwargs: Any) -&gt; None:\n            Hard deletes a record from the database based on provided filters.\n\n        delete(db: AsyncSession, db_row: Optional[Row] = None, **kwargs: Any) -&gt; None:\n            Soft deletes a record if it has an \"is_deleted\" attribute; otherwise, performs a\n            hard delete. Filters or an existing database row can be provided for deletion.\n\n    Examples:\n        Example 1: Basic Usage\n        ----------------------\n        Create a FastCRUD instance for a User model and perform basic CRUD operations.\n        ```python\n        user_crud = FastCRUD(User, UserCreateSchema, UserUpdateSchema)\n        async with db_session() as db:\n            # Create a new user\n            new_user = await user_crud.create(db, UserCreateSchema(name=\"Alice\"))\n            # Read a user\n            user = await user_crud.get(db, id=new_user.id)\n            # Update a user\n            await user_crud.update(db, UserUpdateSchema(email=\"alice@example.com\"), id=new_user.id)\n            # Delete a user\n            await user_crud.delete(db, id=new_user.id)\n        ```\n\n        Example 2: Advanced Filtering and Pagination\n        --------------------------------------------\n        Use advanced filtering, sorting, and pagination for fetching records.\n        ```python\n        product_crud = FastCRUD(Product, ProductCreateSchema)\n        async with db_session() as db:\n            products = await product_crud.get_multi(\n                db, offset=0, limit=10, sort_columns=['price'], sort_orders=['asc']\n            )\n        ```\n\n        Example 3: Join Operations with Custom Schemas\n        ----------------------------------------------\n        Perform join operations between two models using custom schemas for selection.\n        ```python\n        order_crud = FastCRUD(Order, OrderCreateSchema, join_model=Product)\n        async with db_session() as db:\n            orders = await order_crud.get_multi_joined(\n                db, offset=0, limit=5, schema_to_select=OrderReadSchema, join_schema_to_select=ProductReadSchema\n            )\n        ```\n\n        Example 4: Cursor Pagination\n        ----------------------------\n        Implement cursor-based pagination for efficient data retrieval in large datasets.\n        ```python\n        comment_crud = FastCRUD(Comment, CommentCreateSchema)\n        async with db_session() as db:\n            first_page = await comment_crud.get_multi_by_cursor(db, limit=10)\n            next_cursor = first_page['next_cursor']\n            second_page = await comment_crud.get_multi_by_cursor(db, cursor=next_cursor, limit=10)\n        ```\n\n        Example 5: Dynamic Filtering and Counting\n        -----------------------------------------\n        Dynamically filter records based on various criteria and count the results.\n        ```python\n        task_crud = FastCRUD(Task, TaskCreateSchema)\n        async with db_session() as db:\n            completed_tasks = await task_crud.get_multi(db, status='completed')\n            high_priority_task_count = await task_crud.count(db, priority='high')\n        ```\n    \"\"\"\n\n    def __init__(self, model: type[ModelType]) -&gt; None:\n        self.model = model\n\n    def _apply_sorting(\n        self,\n        stmt: sqlalchemy.sql.selectable.Select,\n        sort_columns: Union[str, list[str]],\n        sort_orders: Optional[Union[str, list[str]]] = None,\n    ) -&gt; sqlalchemy.sql.selectable.Select:\n        \"\"\"\n        Apply sorting to a SQLAlchemy query based on specified column names and sort orders.\n\n        Args:\n            stmt: The SQLAlchemy Select statement to which sorting will be applied.\n            sort_columns: A single column name or a list of column names on which to apply sorting.\n            sort_orders: A single sort order ('asc' or 'desc') or a list of sort orders corresponding\n                to the columns in sort_columns. If not provided, defaults to 'asc' for each column.\n\n        Raises:\n            ValueError: Raised if sort orders are provided without corresponding sort columns,\n                or if an invalid sort order is provided (not 'asc' or 'desc').\n            ArgumentError: Raised if an invalid column name is provided that does not exist in the model.\n\n        Returns:\n            The modified Select statement with sorting applied.\n\n        Examples:\n            Applying ascending sort on a single column:\n            &gt;&gt;&gt; stmt = _apply_sorting(stmt, 'name')\n\n            Applying descending sort on a single column:\n            &gt;&gt;&gt; stmt = _apply_sorting(stmt, 'age', 'desc')\n\n            Applying mixed sort orders on multiple columns:\n            &gt;&gt;&gt; stmt = _apply_sorting(stmt, ['name', 'age'], ['asc', 'desc'])\n\n            Applying ascending sort on multiple columns:\n            &gt;&gt;&gt; stmt = _apply_sorting(stmt, ['name', 'age'])\n\n        Note:\n            This method modifies the passed Select statement in-place by applying the order_by clause\n            based on the provided column names and sort orders.\n        \"\"\"\n        if sort_orders and not sort_columns:\n            raise ValueError(\"Sort orders provided without corresponding sort columns.\")\n\n        if sort_columns:\n            if not isinstance(sort_columns, list):\n                sort_columns = [sort_columns]\n\n            if sort_orders:\n                if not isinstance(sort_orders, list):\n                    sort_orders = [sort_orders] * len(sort_columns)\n                if len(sort_columns) != len(sort_orders):\n                    raise ValueError(\n                        \"The length of sort_columns and sort_orders must match.\"\n                    )\n\n                for idx, order in enumerate(sort_orders):\n                    if order not in [\"asc\", \"desc\"]:\n                        raise ValueError(\n                            f\"Invalid sort order: {order}. Only 'asc' or 'desc' are allowed.\"\n                        )\n\n            validated_sort_orders = (\n                [\"asc\"] * len(sort_columns) if not sort_orders else sort_orders\n            )\n\n            for idx, column_name in enumerate(sort_columns):\n                column = getattr(self.model, column_name, None)\n                if not column:\n                    raise ArgumentError(f\"Invalid column name: {column_name}\")\n\n                order = validated_sort_orders[idx]\n                stmt = stmt.order_by(asc(column) if order == \"asc\" else desc(column))\n\n        return stmt\n\n    async def create(self, db: AsyncSession, object: CreateSchemaType) -&gt; ModelType:\n        \"\"\"\n        Create a new record in the database.\n\n        Args:\n            db: The SQLAlchemy async session.\n            object: The Pydantic schema containing the data to be saved.\n\n        Returns:\n            The created database object.\n        \"\"\"\n        object_dict = object.model_dump()\n        db_object: ModelType = self.model(**object_dict)\n        db.add(db_object)\n        await db.commit()\n        return db_object\n\n    async def get(\n        self,\n        db: AsyncSession,\n        schema_to_select: Optional[type[BaseModel]] = None,\n        **kwargs: Any,\n    ) -&gt; Optional[dict]:\n        \"\"\"\n        Fetch a single record based on filters.\n\n        Args:\n            db: The SQLAlchemy async session.\n            schema_to_select: Pydantic schema for selecting specific columns.\n                Default is None to select all columns.\n            **kwargs: Filters to apply to the query.\n\n        Returns:\n            The fetched database row or None if not found.\n        \"\"\"\n        to_select = _extract_matching_columns_from_schema(\n            model=self.model, schema=schema_to_select\n        )\n        stmt = select(*to_select).filter_by(**kwargs)\n\n        db_row = await db.execute(stmt)\n        result: Row = db_row.first()\n        if result is not None:\n            out: dict = dict(result._mapping)\n            return out\n\n        return None\n\n    async def exists(self, db: AsyncSession, **kwargs: Any) -&gt; bool:\n        \"\"\"\n        Check if a record exists based on filters.\n\n        Args:\n            db: The SQLAlchemy async session.\n            **kwargs: Filters to apply to the query.\n\n        Returns:\n            True if a record exists, False otherwise.\n        \"\"\"\n        to_select = _extract_matching_columns_from_kwargs(\n            model=self.model, kwargs=kwargs\n        )\n        stmt = select(*to_select).filter_by(**kwargs).limit(1)\n\n        result = await db.execute(stmt)\n        return result.first() is not None\n\n    async def count(self, db: AsyncSession, **kwargs: Any) -&gt; int:\n        \"\"\"\n        Count the records based on filters.\n\n        Args:\n            db: The SQLAlchemy async session.\n            **kwargs: Filters to apply to the query.\n\n        Returns:\n            Total count of records that match the applied filters.\n\n        Note:\n            This method provides a quick way to get the count of records without retrieving the actual data.\n        \"\"\"\n        conditions = [\n            getattr(self.model, key) == value for key, value in kwargs.items()\n        ]\n        if conditions:\n            combined_conditions = and_(*conditions)\n        else:\n            combined_conditions = true()\n\n        count_query = (\n            select(func.count()).select_from(self.model).where(combined_conditions)\n        )\n        total_count: int = await db.scalar(count_query)\n\n        return total_count\n\n    async def get_multi(\n        self,\n        db: AsyncSession,\n        offset: int = 0,\n        limit: int = 100,\n        schema_to_select: Optional[type[BaseModel]] = None,\n        sort_columns: Optional[Union[str, list[str]]] = None,\n        sort_orders: Optional[Union[str, list[str]]] = None,\n        return_as_model: bool = False,\n        **kwargs: Any,\n    ) -&gt; dict[str, Any]:\n        \"\"\"\n        Fetch multiple records based on filters, with optional sorting, pagination, and model conversion.\n\n        Args:\n            db: The SQLAlchemy async session.\n            offset: Number of rows to skip before fetching. Must be non-negative.\n            limit: Maximum number of rows to fetch. Must be non-negative.\n            schema_to_select: Pydantic schema for selecting specific columns.\n            sort_columns: Single column name or a list of column names for sorting.\n            sort_orders: Single sort direction ('asc' or 'desc') or a list of directions corresponding to the columns in sort_columns. Defaults to 'asc'.\n            return_as_model: If True, returns the data as instances of the Pydantic model.\n            **kwargs: Filters to apply to the query.\n\n        Returns:\n            A dictionary containing the fetched rows under 'data' key and total count under 'total_count'.\n\n        Raises:\n            ValueError: If limit or offset is negative, or if schema_to_select is required but not provided or invalid.\n\n        Examples:\n            Fetch the first 10 users:\n            ```python\n            users = await crud.get_multi(db, 0, 10)\n            ```\n\n            Fetch next 10 users with sorting:\n            ```python\n            users = await crud.get_multi(db, 10, 10, sort_columns='username', sort_orders='desc')\n            ```\n\n            Fetch users with filtering and multiple column sorting:\n            ```python\n            users = await crud.get_multi(db, 0, 10, is_active=True, sort_columns=['username', 'email'], sort_orders=['asc', 'desc'])\n            ```\n        \"\"\"\n        if limit &lt; 0 or offset &lt; 0:\n            raise ValueError(\"Limit and offset must be non-negative.\")\n\n        to_select = _extract_matching_columns_from_schema(self.model, schema_to_select)\n        stmt = select(*to_select).filter_by(**kwargs)\n\n        if sort_columns:\n            stmt = self._apply_sorting(stmt, sort_columns, sort_orders)\n\n        stmt = stmt.offset(offset).limit(limit)\n        result = await db.execute(stmt)\n        data = [dict(row) for row in result.mappings()]\n\n        if return_as_model:\n            if not schema_to_select:\n                raise ValueError(\n                    \"schema_to_select must be provided when return_as_model is True.\"\n                )\n            try:\n                data = [schema_to_select.model_construct(**row) for row in data]\n            except ValidationError as e:\n                raise ValueError(\n                    f\"Data validation error for schema {schema_to_select.__name__}: {e}\"\n                )\n\n        total_count = await self.count(db=db, **kwargs)\n        return {\"data\": data, \"total_count\": total_count}\n\n    async def get_joined(\n        self,\n        db: AsyncSession,\n        join_model: type[ModelType],\n        join_prefix: Optional[str] = None,\n        join_on: Optional[Union[Join, None]] = None,\n        schema_to_select: Optional[type[BaseModel]] = None,\n        join_schema_to_select: Optional[type[BaseModel]] = None,\n        join_type: str = \"left\",\n        **kwargs: Any,\n    ) -&gt; Optional[dict[str, Any]]:\n        \"\"\"\n        Fetches a single record with a join on another model. If 'join_on' is not provided, the method attempts\n        to automatically detect the join condition using foreign key relationships.\n\n        Args:\n            db: The SQLAlchemy async session.\n            join_model: The model to join with.\n            join_prefix: Optional prefix to be added to all columns of the joined model. If None, no prefix is added.\n            join_on: SQLAlchemy Join object for specifying the ON clause of the join. If None, the join condition is\n                auto-detected based on foreign keys.\n            schema_to_select: Pydantic schema for selecting specific columns from the primary model.\n            join_schema_to_select: Pydantic schema for selecting specific columns from the joined model.\n            join_type: Specifies the type of join operation to perform. Can be \"left\" for a left outer join or \"inner\" for an inner join.\n            **kwargs: Filters to apply to the query.\n\n        Returns:\n            The fetched database row or None if not found.\n\n        Examples:\n            Simple example: Joining User and Tier models without explicitly providing join_on\n            ```python\n            result = await crud_user.get_joined(\n                db=session,\n                join_model=Tier,\n                schema_to_select=UserSchema,\n                join_schema_to_select=TierSchema\n            )\n            ```\n\n            Complex example: Joining with a custom join condition, additional filter parameters, and a prefix\n            ```python\n            from sqlalchemy import and_\n            result = await crud_user.get_joined(\n                db=session,\n                join_model=Tier,\n                join_prefix=\"tier_\",\n                join_on=and_(User.tier_id == Tier.id, User.is_superuser == True),\n                schema_to_select=UserSchema,\n                join_schema_to_select=TierSchema,\n                username=\"john_doe\"\n            )\n            ```\n\n            Return example: prefix added, no schema_to_select or join_schema_to_select\n            ```python\n            {\n                \"id\": 1,\n                \"name\": \"John Doe\",\n                \"username\": \"john_doe\",\n                \"email\": \"johndoe@example.com\",\n                \"hashed_password\": \"hashed_password_example\",\n                \"profile_image_url\": \"https://profileimageurl.com/default.jpg\",\n                \"uuid\": \"123e4567-e89b-12d3-a456-426614174000\",\n                \"created_at\": \"2023-01-01T12:00:00\",\n                \"updated_at\": \"2023-01-02T12:00:00\",\n                \"deleted_at\": null,\n                \"is_deleted\": false,\n                \"is_superuser\": false,\n                \"tier_id\": 2,\n                \"tier_name\": \"Premium\",\n                \"tier_created_at\": \"2022-12-01T10:00:00\",\n                \"tier_updated_at\": \"2023-01-01T11:00:00\"\n            }\n            ```\n        \"\"\"\n        if join_on is None:\n            join_on = _auto_detect_join_condition(self.model, join_model)\n\n        primary_select = _extract_matching_columns_from_schema(\n            model=self.model, schema=schema_to_select\n        )\n        join_select = []\n\n        if join_schema_to_select:\n            columns = _extract_matching_columns_from_schema(\n                model=join_model, schema=join_schema_to_select\n            )\n        else:\n            columns = inspect(join_model).c\n\n        for column in columns:\n            labeled_column = _add_column_with_prefix(column, join_prefix)\n            if f\"{join_prefix}{column.name}\" not in [\n                col.name for col in primary_select\n            ]:\n                join_select.append(labeled_column)\n\n        if join_type == \"left\":\n            stmt = select(*primary_select, *join_select).outerjoin(join_model, join_on)\n        elif join_type == \"inner\":\n            stmt = select(*primary_select, *join_select).join(join_model, join_on)\n        else:\n            raise ValueError(\n                f\"Invalid join type: {join_type}. Only 'left' or 'inner' are valid.\"\n            )\n\n        for key, value in kwargs.items():\n            if hasattr(self.model, key):\n                stmt = stmt.where(getattr(self.model, key) == value)\n\n        db_row = await db.execute(stmt)\n        result: Row = db_row.first()\n        if result:\n            out: dict = dict(result._mapping)\n            return out\n\n        return None\n\n    async def get_multi_joined(\n        self,\n        db: AsyncSession,\n        join_model: type[ModelType],\n        join_prefix: Optional[str] = None,\n        join_on: Optional[Join] = None,\n        schema_to_select: Optional[type[BaseModel]] = None,\n        join_schema_to_select: Optional[type[BaseModel]] = None,\n        join_type: str = \"left\",\n        offset: int = 0,\n        limit: int = 100,\n        sort_columns: Optional[Union[str, list[str]]] = None,\n        sort_orders: Optional[Union[str, list[str]]] = None,\n        return_as_model: bool = False,\n        **kwargs: Any,\n    ) -&gt; dict[str, Any]:\n        \"\"\"\n        Fetch multiple records with a join on another model, allowing for pagination, optional sorting, and model conversion.\n\n        Args:\n            db: The SQLAlchemy async session.\n            join_model: The model to join with.\n            join_prefix: Optional prefix to be added to all columns of the joined model. If None, no prefix is added.\n            join_on: SQLAlchemy Join object for specifying the ON clause of the join. If None, the join condition is auto-detected based on foreign keys.\n            schema_to_select: Pydantic schema for selecting specific columns from the primary model.\n            join_schema_to_select: Pydantic schema for selecting specific columns from the joined model.\n            join_type: Specifies the type of join operation to perform. Can be \"left\" for a left outer join or \"inner\" for an inner join.\n            offset: The offset (number of records to skip) for pagination.\n            limit: The limit (maximum number of records to return) for pagination.\n            sort_columns: A single column name or a list of column names on which to apply sorting.\n            sort_orders: A single sort order ('asc' or 'desc') or a list of sort orders corresponding to the columns in sort_columns. If not provided, defaults to 'asc' for each column.\n            return_as_model: If True, converts the fetched data to Pydantic models based on schema_to_select. Defaults to False.\n            **kwargs: Filters to apply to the primary query.\n\n        Returns:\n            A dictionary containing the fetched rows under 'data' key and total count under 'total_count'.\n\n        Raises:\n            ValueError: If limit or offset is negative, or if schema_to_select is required but not provided or invalid.\n\n        Examples:\n            Fetching multiple User records joined with Tier records, using left join, returning raw data:\n            &gt;&gt;&gt; users = await crud_user.get_multi_joined(\n                    db=session,\n                    join_model=Tier,\n                    join_prefix=\"tier_\",\n                    schema_to_select=UserSchema,\n                    join_schema_to_select=TierSchema,\n                    offset=0,\n                    limit=10\n                )\n\n            Fetching and sorting by username in descending order, returning as Pydantic model:\n            &gt;&gt;&gt; users = await crud_user.get_multi_joined(\n                    db=session,\n                    join_model=Tier,\n                    join_prefix=\"tier_\",\n                    schema_to_select=UserSchema,\n                    join_schema_to_select=TierSchema,\n                    offset=0,\n                    limit=10,\n                    sort_columns=['username'],\n                    sort_orders=['desc'],\n                    return_as_model=True\n                )\n\n            Fetching with complex conditions and custom join, returning as Pydantic model:\n            &gt;&gt;&gt; users = await crud_user.get_multi_joined(\n                    db=session,\n                    join_model=Tier,\n                    join_prefix=\"tier_\",\n                    join_on=User.tier_id == Tier.id,\n                    schema_to_select=UserSchema,\n                    join_schema_to_select=TierSchema,\n                    offset=0,\n                    limit=10,\n                    is_active=True,\n                    return_as_model=True\n                )\n        \"\"\"\n        if limit &lt; 0 or offset &lt; 0:\n            raise ValueError(\"Limit and offset must be non-negative.\")\n\n        if join_on is None:\n            join_on = _auto_detect_join_condition(self.model, join_model)\n\n        primary_select = _extract_matching_columns_from_schema(\n            model=self.model, schema=schema_to_select\n        )\n        join_select = []\n\n        if join_schema_to_select:\n            columns = _extract_matching_columns_from_schema(\n                model=join_model, schema=join_schema_to_select\n            )\n        else:\n            columns = inspect(join_model).c\n\n        for column in columns:\n            labeled_column = _add_column_with_prefix(column, join_prefix)\n            if f\"{join_prefix}{column.name}\" not in [\n                col.name for col in primary_select\n            ]:\n                join_select.append(labeled_column)\n\n        if join_type == \"left\":\n            stmt = select(*primary_select, *join_select).outerjoin(join_model, join_on)\n        elif join_type == \"inner\":\n            stmt = select(*primary_select, *join_select).join(join_model, join_on)\n        else:\n            raise ValueError(\n                f\"Invalid join type: {join_type}. Only 'left' or 'inner' are valid.\"\n            )\n\n        for key, value in kwargs.items():\n            if hasattr(self.model, key):\n                stmt = stmt.where(getattr(self.model, key) == value)\n\n        if sort_columns:\n            stmt = self._apply_sorting(stmt, sort_columns, sort_orders)\n\n        stmt = stmt.offset(offset).limit(limit)\n\n        db_rows = await db.execute(stmt)\n        data = [dict(row._mapping) for row in db_rows]\n\n        if return_as_model and schema_to_select:\n            data = [schema_to_select.model_construct(**row) for row in data]\n\n        total_count = await self.count(db=db, **kwargs)\n\n        return {\"data\": data, \"total_count\": total_count}\n\n    async def get_multi_by_cursor(\n        self,\n        db: AsyncSession,\n        cursor: Any = None,\n        limit: int = 100,\n        schema_to_select: Optional[type[BaseModel]] = None,\n        sort_column: str = \"id\",\n        sort_order: str = \"asc\",\n        **kwargs: Any,\n    ) -&gt; dict[str, Any]:\n        \"\"\"\n        Fetch multiple records based on a cursor for pagination, with optional sorting.\n\n        Args:\n            db: The SQLAlchemy async session.\n            cursor: The cursor value to start fetching records from. Defaults to None.\n            limit: Maximum number of rows to fetch.\n            schema_to_select: Pydantic schema for selecting specific columns.\n            sort_column: Column name to use for sorting and cursor pagination.\n            sort_order: Sorting direction, either 'asc' or 'desc'.\n            **kwargs: Additional filters to apply to the query.\n\n        Returns:\n            A dictionary containing the fetched rows under 'data' key and the next cursor value under 'next_cursor'.\n\n        Usage Examples:\n            # Fetch the first set of records (e.g., the first page in an infinite scrolling scenario)\n            &gt;&gt;&gt; first_page = await crud.get_multi_by_cursor(db, limit=10, sort_column='created_at', sort_order='desc')\n\n            # Fetch the next set of records using the cursor from the first page\n            &gt;&gt;&gt; next_cursor = first_page['next_cursor']\n            &gt;&gt;&gt; second_page = await crud.get_multi_by_cursor(db, cursor=next_cursor, limit=10, sort_column='created_at', sort_order='desc')\n\n        Note:\n            This method is designed for efficient pagination in large datasets and is ideal for infinite scrolling features.\n            Make sure the column used for cursor pagination is indexed for performance.\n            This method assumes that your records can be ordered by a unique, sequential field (like `id` or `created_at`).\n        \"\"\"\n        if limit == 0:\n            return {\"data\": [], \"next_cursor\": None}\n\n        to_select = _extract_matching_columns_from_schema(self.model, schema_to_select)\n        stmt = select(*to_select).filter_by(**kwargs)\n\n        if cursor:\n            if sort_order == \"asc\":\n                stmt = stmt.where(getattr(self.model, sort_column) &gt; cursor)\n            else:\n                stmt = stmt.where(getattr(self.model, sort_column) &lt; cursor)\n\n        stmt = stmt.order_by(\n            asc(getattr(self.model, sort_column))\n            if sort_order == \"asc\"\n            else desc(getattr(self.model, sort_column))\n        )\n        stmt = stmt.limit(limit)\n\n        result = await db.execute(stmt)\n        data = [dict(row) for row in result.mappings()]\n\n        next_cursor = None\n        if len(data) == limit:\n            next_cursor = data[-1][sort_column]\n\n        return {\"data\": data, \"next_cursor\": next_cursor}\n\n    async def update(\n        self,\n        db: AsyncSession,\n        object: Union[UpdateSchemaType, dict[str, Any]],\n        **kwargs: Any,\n    ) -&gt; None:\n        \"\"\"\n        Update an existing record in the database.\n\n        Args:\n            db: The SQLAlchemy async session.\n            object: The Pydantic schema or dictionary containing the data to be updated.\n            **kwargs: Filters for the update.\n\n        Returns:\n            None\n\n        Raises:\n            ValueError: If extra fields not present in the model are provided in the update data.\n        \"\"\"\n        if isinstance(object, dict):\n            update_data = object\n        else:\n            update_data = object.model_dump(exclude_unset=True)\n\n        if \"updated_at\" in update_data.keys():\n            update_data[\"updated_at\"] = datetime.now(timezone.utc)\n\n        model_columns = {column.name for column in inspect(self.model).c}\n        extra_fields = set(update_data) - model_columns\n        if extra_fields:\n            raise ValueError(f\"Extra fields provided: {extra_fields}\")\n\n        stmt = update(self.model).filter_by(**kwargs).values(update_data)\n\n        await db.execute(stmt)\n        await db.commit()\n\n    async def db_delete(self, db: AsyncSession, **kwargs: Any) -&gt; None:\n        \"\"\"\n        Delete a record in the database.\n\n        Args:\n            db: The SQLAlchemy async session.\n            **kwargs: Filters for the delete.\n\n        Returns:\n            None\n        \"\"\"\n        stmt = delete(self.model).filter_by(**kwargs)\n        await db.execute(stmt)\n        await db.commit()\n\n    async def delete(\n        self, db: AsyncSession, db_row: Optional[Row] = None, **kwargs: Any\n    ) -&gt; None:\n        \"\"\"\n        Soft delete a record if it has \"is_deleted\" attribute, otherwise perform a hard delete.\n\n        Args:\n            db: The SQLAlchemy async session.\n            db_row: Existing database row to delete. If None, it will be fetched based on `kwargs`. Default is None.\n            **kwargs: Filters for fetching the database row if not provided.\n\n        Returns:\n            None\n        \"\"\"\n        db_row = db_row or await self.exists(db=db, **kwargs)\n        if db_row:\n            if \"is_deleted\" in self.model.__table__.columns:\n                object_dict = {\n                    \"is_deleted\": True,\n                    \"deleted_at\": datetime.now(timezone.utc),\n                }\n                stmt = update(self.model).filter_by(**kwargs).values(object_dict)\n\n                await db.execute(stmt)\n                await db.commit()\n\n            else:\n                stmt = delete(self.model).filter_by(**kwargs)\n                await db.execute(stmt)\n                await db.commit()\n</code></pre>"},{"location":"api/fastcrud/#fastcrud.FastCRUD.count","title":"<code>count(db, **kwargs)</code>  <code>async</code>","text":"<p>Count the records based on filters.</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>AsyncSession</code> <p>The SQLAlchemy async session.</p> required <code>**kwargs</code> <code>Any</code> <p>Filters to apply to the query.</p> <code>{}</code> <p>Returns:</p> Type Description <code>int</code> <p>Total count of records that match the applied filters.</p> Note <p>This method provides a quick way to get the count of records without retrieving the actual data.</p> Source code in <code>fastcrud/crud/fast_crud.py</code> <pre><code>async def count(self, db: AsyncSession, **kwargs: Any) -&gt; int:\n    \"\"\"\n    Count the records based on filters.\n\n    Args:\n        db: The SQLAlchemy async session.\n        **kwargs: Filters to apply to the query.\n\n    Returns:\n        Total count of records that match the applied filters.\n\n    Note:\n        This method provides a quick way to get the count of records without retrieving the actual data.\n    \"\"\"\n    conditions = [\n        getattr(self.model, key) == value for key, value in kwargs.items()\n    ]\n    if conditions:\n        combined_conditions = and_(*conditions)\n    else:\n        combined_conditions = true()\n\n    count_query = (\n        select(func.count()).select_from(self.model).where(combined_conditions)\n    )\n    total_count: int = await db.scalar(count_query)\n\n    return total_count\n</code></pre>"},{"location":"api/fastcrud/#fastcrud.FastCRUD.create","title":"<code>create(db, object)</code>  <code>async</code>","text":"<p>Create a new record in the database.</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>AsyncSession</code> <p>The SQLAlchemy async session.</p> required <code>object</code> <code>CreateSchemaType</code> <p>The Pydantic schema containing the data to be saved.</p> required <p>Returns:</p> Type Description <code>ModelType</code> <p>The created database object.</p> Source code in <code>fastcrud/crud/fast_crud.py</code> <pre><code>async def create(self, db: AsyncSession, object: CreateSchemaType) -&gt; ModelType:\n    \"\"\"\n    Create a new record in the database.\n\n    Args:\n        db: The SQLAlchemy async session.\n        object: The Pydantic schema containing the data to be saved.\n\n    Returns:\n        The created database object.\n    \"\"\"\n    object_dict = object.model_dump()\n    db_object: ModelType = self.model(**object_dict)\n    db.add(db_object)\n    await db.commit()\n    return db_object\n</code></pre>"},{"location":"api/fastcrud/#fastcrud.FastCRUD.db_delete","title":"<code>db_delete(db, **kwargs)</code>  <code>async</code>","text":"<p>Delete a record in the database.</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>AsyncSession</code> <p>The SQLAlchemy async session.</p> required <code>**kwargs</code> <code>Any</code> <p>Filters for the delete.</p> <code>{}</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>fastcrud/crud/fast_crud.py</code> <pre><code>async def db_delete(self, db: AsyncSession, **kwargs: Any) -&gt; None:\n    \"\"\"\n    Delete a record in the database.\n\n    Args:\n        db: The SQLAlchemy async session.\n        **kwargs: Filters for the delete.\n\n    Returns:\n        None\n    \"\"\"\n    stmt = delete(self.model).filter_by(**kwargs)\n    await db.execute(stmt)\n    await db.commit()\n</code></pre>"},{"location":"api/fastcrud/#fastcrud.FastCRUD.delete","title":"<code>delete(db, db_row=None, **kwargs)</code>  <code>async</code>","text":"<p>Soft delete a record if it has \"is_deleted\" attribute, otherwise perform a hard delete.</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>AsyncSession</code> <p>The SQLAlchemy async session.</p> required <code>db_row</code> <code>Optional[Row]</code> <p>Existing database row to delete. If None, it will be fetched based on <code>kwargs</code>. Default is None.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Filters for fetching the database row if not provided.</p> <code>{}</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>fastcrud/crud/fast_crud.py</code> <pre><code>async def delete(\n    self, db: AsyncSession, db_row: Optional[Row] = None, **kwargs: Any\n) -&gt; None:\n    \"\"\"\n    Soft delete a record if it has \"is_deleted\" attribute, otherwise perform a hard delete.\n\n    Args:\n        db: The SQLAlchemy async session.\n        db_row: Existing database row to delete. If None, it will be fetched based on `kwargs`. Default is None.\n        **kwargs: Filters for fetching the database row if not provided.\n\n    Returns:\n        None\n    \"\"\"\n    db_row = db_row or await self.exists(db=db, **kwargs)\n    if db_row:\n        if \"is_deleted\" in self.model.__table__.columns:\n            object_dict = {\n                \"is_deleted\": True,\n                \"deleted_at\": datetime.now(timezone.utc),\n            }\n            stmt = update(self.model).filter_by(**kwargs).values(object_dict)\n\n            await db.execute(stmt)\n            await db.commit()\n\n        else:\n            stmt = delete(self.model).filter_by(**kwargs)\n            await db.execute(stmt)\n            await db.commit()\n</code></pre>"},{"location":"api/fastcrud/#fastcrud.FastCRUD.exists","title":"<code>exists(db, **kwargs)</code>  <code>async</code>","text":"<p>Check if a record exists based on filters.</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>AsyncSession</code> <p>The SQLAlchemy async session.</p> required <code>**kwargs</code> <code>Any</code> <p>Filters to apply to the query.</p> <code>{}</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if a record exists, False otherwise.</p> Source code in <code>fastcrud/crud/fast_crud.py</code> <pre><code>async def exists(self, db: AsyncSession, **kwargs: Any) -&gt; bool:\n    \"\"\"\n    Check if a record exists based on filters.\n\n    Args:\n        db: The SQLAlchemy async session.\n        **kwargs: Filters to apply to the query.\n\n    Returns:\n        True if a record exists, False otherwise.\n    \"\"\"\n    to_select = _extract_matching_columns_from_kwargs(\n        model=self.model, kwargs=kwargs\n    )\n    stmt = select(*to_select).filter_by(**kwargs).limit(1)\n\n    result = await db.execute(stmt)\n    return result.first() is not None\n</code></pre>"},{"location":"api/fastcrud/#fastcrud.FastCRUD.get","title":"<code>get(db, schema_to_select=None, **kwargs)</code>  <code>async</code>","text":"<p>Fetch a single record based on filters.</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>AsyncSession</code> <p>The SQLAlchemy async session.</p> required <code>schema_to_select</code> <code>Optional[type[BaseModel]]</code> <p>Pydantic schema for selecting specific columns. Default is None to select all columns.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Filters to apply to the query.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Optional[dict]</code> <p>The fetched database row or None if not found.</p> Source code in <code>fastcrud/crud/fast_crud.py</code> <pre><code>async def get(\n    self,\n    db: AsyncSession,\n    schema_to_select: Optional[type[BaseModel]] = None,\n    **kwargs: Any,\n) -&gt; Optional[dict]:\n    \"\"\"\n    Fetch a single record based on filters.\n\n    Args:\n        db: The SQLAlchemy async session.\n        schema_to_select: Pydantic schema for selecting specific columns.\n            Default is None to select all columns.\n        **kwargs: Filters to apply to the query.\n\n    Returns:\n        The fetched database row or None if not found.\n    \"\"\"\n    to_select = _extract_matching_columns_from_schema(\n        model=self.model, schema=schema_to_select\n    )\n    stmt = select(*to_select).filter_by(**kwargs)\n\n    db_row = await db.execute(stmt)\n    result: Row = db_row.first()\n    if result is not None:\n        out: dict = dict(result._mapping)\n        return out\n\n    return None\n</code></pre>"},{"location":"api/fastcrud/#fastcrud.FastCRUD.get_joined","title":"<code>get_joined(db, join_model, join_prefix=None, join_on=None, schema_to_select=None, join_schema_to_select=None, join_type='left', **kwargs)</code>  <code>async</code>","text":"<p>Fetches a single record with a join on another model. If 'join_on' is not provided, the method attempts to automatically detect the join condition using foreign key relationships.</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>AsyncSession</code> <p>The SQLAlchemy async session.</p> required <code>join_model</code> <code>type[ModelType]</code> <p>The model to join with.</p> required <code>join_prefix</code> <code>Optional[str]</code> <p>Optional prefix to be added to all columns of the joined model. If None, no prefix is added.</p> <code>None</code> <code>join_on</code> <code>Optional[Union[Join, None]]</code> <p>SQLAlchemy Join object for specifying the ON clause of the join. If None, the join condition is auto-detected based on foreign keys.</p> <code>None</code> <code>schema_to_select</code> <code>Optional[type[BaseModel]]</code> <p>Pydantic schema for selecting specific columns from the primary model.</p> <code>None</code> <code>join_schema_to_select</code> <code>Optional[type[BaseModel]]</code> <p>Pydantic schema for selecting specific columns from the joined model.</p> <code>None</code> <code>join_type</code> <code>str</code> <p>Specifies the type of join operation to perform. Can be \"left\" for a left outer join or \"inner\" for an inner join.</p> <code>'left'</code> <code>**kwargs</code> <code>Any</code> <p>Filters to apply to the query.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Optional[dict[str, Any]]</code> <p>The fetched database row or None if not found.</p> <p>Examples:</p> <p>Simple example: Joining User and Tier models without explicitly providing join_on <pre><code>result = await crud_user.get_joined(\n    db=session,\n    join_model=Tier,\n    schema_to_select=UserSchema,\n    join_schema_to_select=TierSchema\n)\n</code></pre></p> <p>Complex example: Joining with a custom join condition, additional filter parameters, and a prefix <pre><code>from sqlalchemy import and_\nresult = await crud_user.get_joined(\n    db=session,\n    join_model=Tier,\n    join_prefix=\"tier_\",\n    join_on=and_(User.tier_id == Tier.id, User.is_superuser == True),\n    schema_to_select=UserSchema,\n    join_schema_to_select=TierSchema,\n    username=\"john_doe\"\n)\n</code></pre></p> <p>Return example: prefix added, no schema_to_select or join_schema_to_select <pre><code>{\n    \"id\": 1,\n    \"name\": \"John Doe\",\n    \"username\": \"john_doe\",\n    \"email\": \"johndoe@example.com\",\n    \"hashed_password\": \"hashed_password_example\",\n    \"profile_image_url\": \"https://profileimageurl.com/default.jpg\",\n    \"uuid\": \"123e4567-e89b-12d3-a456-426614174000\",\n    \"created_at\": \"2023-01-01T12:00:00\",\n    \"updated_at\": \"2023-01-02T12:00:00\",\n    \"deleted_at\": null,\n    \"is_deleted\": false,\n    \"is_superuser\": false,\n    \"tier_id\": 2,\n    \"tier_name\": \"Premium\",\n    \"tier_created_at\": \"2022-12-01T10:00:00\",\n    \"tier_updated_at\": \"2023-01-01T11:00:00\"\n}\n</code></pre></p> Source code in <code>fastcrud/crud/fast_crud.py</code> <pre><code>async def get_joined(\n    self,\n    db: AsyncSession,\n    join_model: type[ModelType],\n    join_prefix: Optional[str] = None,\n    join_on: Optional[Union[Join, None]] = None,\n    schema_to_select: Optional[type[BaseModel]] = None,\n    join_schema_to_select: Optional[type[BaseModel]] = None,\n    join_type: str = \"left\",\n    **kwargs: Any,\n) -&gt; Optional[dict[str, Any]]:\n    \"\"\"\n    Fetches a single record with a join on another model. If 'join_on' is not provided, the method attempts\n    to automatically detect the join condition using foreign key relationships.\n\n    Args:\n        db: The SQLAlchemy async session.\n        join_model: The model to join with.\n        join_prefix: Optional prefix to be added to all columns of the joined model. If None, no prefix is added.\n        join_on: SQLAlchemy Join object for specifying the ON clause of the join. If None, the join condition is\n            auto-detected based on foreign keys.\n        schema_to_select: Pydantic schema for selecting specific columns from the primary model.\n        join_schema_to_select: Pydantic schema for selecting specific columns from the joined model.\n        join_type: Specifies the type of join operation to perform. Can be \"left\" for a left outer join or \"inner\" for an inner join.\n        **kwargs: Filters to apply to the query.\n\n    Returns:\n        The fetched database row or None if not found.\n\n    Examples:\n        Simple example: Joining User and Tier models without explicitly providing join_on\n        ```python\n        result = await crud_user.get_joined(\n            db=session,\n            join_model=Tier,\n            schema_to_select=UserSchema,\n            join_schema_to_select=TierSchema\n        )\n        ```\n\n        Complex example: Joining with a custom join condition, additional filter parameters, and a prefix\n        ```python\n        from sqlalchemy import and_\n        result = await crud_user.get_joined(\n            db=session,\n            join_model=Tier,\n            join_prefix=\"tier_\",\n            join_on=and_(User.tier_id == Tier.id, User.is_superuser == True),\n            schema_to_select=UserSchema,\n            join_schema_to_select=TierSchema,\n            username=\"john_doe\"\n        )\n        ```\n\n        Return example: prefix added, no schema_to_select or join_schema_to_select\n        ```python\n        {\n            \"id\": 1,\n            \"name\": \"John Doe\",\n            \"username\": \"john_doe\",\n            \"email\": \"johndoe@example.com\",\n            \"hashed_password\": \"hashed_password_example\",\n            \"profile_image_url\": \"https://profileimageurl.com/default.jpg\",\n            \"uuid\": \"123e4567-e89b-12d3-a456-426614174000\",\n            \"created_at\": \"2023-01-01T12:00:00\",\n            \"updated_at\": \"2023-01-02T12:00:00\",\n            \"deleted_at\": null,\n            \"is_deleted\": false,\n            \"is_superuser\": false,\n            \"tier_id\": 2,\n            \"tier_name\": \"Premium\",\n            \"tier_created_at\": \"2022-12-01T10:00:00\",\n            \"tier_updated_at\": \"2023-01-01T11:00:00\"\n        }\n        ```\n    \"\"\"\n    if join_on is None:\n        join_on = _auto_detect_join_condition(self.model, join_model)\n\n    primary_select = _extract_matching_columns_from_schema(\n        model=self.model, schema=schema_to_select\n    )\n    join_select = []\n\n    if join_schema_to_select:\n        columns = _extract_matching_columns_from_schema(\n            model=join_model, schema=join_schema_to_select\n        )\n    else:\n        columns = inspect(join_model).c\n\n    for column in columns:\n        labeled_column = _add_column_with_prefix(column, join_prefix)\n        if f\"{join_prefix}{column.name}\" not in [\n            col.name for col in primary_select\n        ]:\n            join_select.append(labeled_column)\n\n    if join_type == \"left\":\n        stmt = select(*primary_select, *join_select).outerjoin(join_model, join_on)\n    elif join_type == \"inner\":\n        stmt = select(*primary_select, *join_select).join(join_model, join_on)\n    else:\n        raise ValueError(\n            f\"Invalid join type: {join_type}. Only 'left' or 'inner' are valid.\"\n        )\n\n    for key, value in kwargs.items():\n        if hasattr(self.model, key):\n            stmt = stmt.where(getattr(self.model, key) == value)\n\n    db_row = await db.execute(stmt)\n    result: Row = db_row.first()\n    if result:\n        out: dict = dict(result._mapping)\n        return out\n\n    return None\n</code></pre>"},{"location":"api/fastcrud/#fastcrud.FastCRUD.get_multi","title":"<code>get_multi(db, offset=0, limit=100, schema_to_select=None, sort_columns=None, sort_orders=None, return_as_model=False, **kwargs)</code>  <code>async</code>","text":"<p>Fetch multiple records based on filters, with optional sorting, pagination, and model conversion.</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>AsyncSession</code> <p>The SQLAlchemy async session.</p> required <code>offset</code> <code>int</code> <p>Number of rows to skip before fetching. Must be non-negative.</p> <code>0</code> <code>limit</code> <code>int</code> <p>Maximum number of rows to fetch. Must be non-negative.</p> <code>100</code> <code>schema_to_select</code> <code>Optional[type[BaseModel]]</code> <p>Pydantic schema for selecting specific columns.</p> <code>None</code> <code>sort_columns</code> <code>Optional[Union[str, list[str]]]</code> <p>Single column name or a list of column names for sorting.</p> <code>None</code> <code>sort_orders</code> <code>Optional[Union[str, list[str]]]</code> <p>Single sort direction ('asc' or 'desc') or a list of directions corresponding to the columns in sort_columns. Defaults to 'asc'.</p> <code>None</code> <code>return_as_model</code> <code>bool</code> <p>If True, returns the data as instances of the Pydantic model.</p> <code>False</code> <code>**kwargs</code> <code>Any</code> <p>Filters to apply to the query.</p> <code>{}</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>A dictionary containing the fetched rows under 'data' key and total count under 'total_count'.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If limit or offset is negative, or if schema_to_select is required but not provided or invalid.</p> <p>Examples:</p> <p>Fetch the first 10 users: <pre><code>users = await crud.get_multi(db, 0, 10)\n</code></pre></p> <p>Fetch next 10 users with sorting: <pre><code>users = await crud.get_multi(db, 10, 10, sort_columns='username', sort_orders='desc')\n</code></pre></p> <p>Fetch users with filtering and multiple column sorting: <pre><code>users = await crud.get_multi(db, 0, 10, is_active=True, sort_columns=['username', 'email'], sort_orders=['asc', 'desc'])\n</code></pre></p> Source code in <code>fastcrud/crud/fast_crud.py</code> <pre><code>async def get_multi(\n    self,\n    db: AsyncSession,\n    offset: int = 0,\n    limit: int = 100,\n    schema_to_select: Optional[type[BaseModel]] = None,\n    sort_columns: Optional[Union[str, list[str]]] = None,\n    sort_orders: Optional[Union[str, list[str]]] = None,\n    return_as_model: bool = False,\n    **kwargs: Any,\n) -&gt; dict[str, Any]:\n    \"\"\"\n    Fetch multiple records based on filters, with optional sorting, pagination, and model conversion.\n\n    Args:\n        db: The SQLAlchemy async session.\n        offset: Number of rows to skip before fetching. Must be non-negative.\n        limit: Maximum number of rows to fetch. Must be non-negative.\n        schema_to_select: Pydantic schema for selecting specific columns.\n        sort_columns: Single column name or a list of column names for sorting.\n        sort_orders: Single sort direction ('asc' or 'desc') or a list of directions corresponding to the columns in sort_columns. Defaults to 'asc'.\n        return_as_model: If True, returns the data as instances of the Pydantic model.\n        **kwargs: Filters to apply to the query.\n\n    Returns:\n        A dictionary containing the fetched rows under 'data' key and total count under 'total_count'.\n\n    Raises:\n        ValueError: If limit or offset is negative, or if schema_to_select is required but not provided or invalid.\n\n    Examples:\n        Fetch the first 10 users:\n        ```python\n        users = await crud.get_multi(db, 0, 10)\n        ```\n\n        Fetch next 10 users with sorting:\n        ```python\n        users = await crud.get_multi(db, 10, 10, sort_columns='username', sort_orders='desc')\n        ```\n\n        Fetch users with filtering and multiple column sorting:\n        ```python\n        users = await crud.get_multi(db, 0, 10, is_active=True, sort_columns=['username', 'email'], sort_orders=['asc', 'desc'])\n        ```\n    \"\"\"\n    if limit &lt; 0 or offset &lt; 0:\n        raise ValueError(\"Limit and offset must be non-negative.\")\n\n    to_select = _extract_matching_columns_from_schema(self.model, schema_to_select)\n    stmt = select(*to_select).filter_by(**kwargs)\n\n    if sort_columns:\n        stmt = self._apply_sorting(stmt, sort_columns, sort_orders)\n\n    stmt = stmt.offset(offset).limit(limit)\n    result = await db.execute(stmt)\n    data = [dict(row) for row in result.mappings()]\n\n    if return_as_model:\n        if not schema_to_select:\n            raise ValueError(\n                \"schema_to_select must be provided when return_as_model is True.\"\n            )\n        try:\n            data = [schema_to_select.model_construct(**row) for row in data]\n        except ValidationError as e:\n            raise ValueError(\n                f\"Data validation error for schema {schema_to_select.__name__}: {e}\"\n            )\n\n    total_count = await self.count(db=db, **kwargs)\n    return {\"data\": data, \"total_count\": total_count}\n</code></pre>"},{"location":"api/fastcrud/#fastcrud.FastCRUD.get_multi_by_cursor","title":"<code>get_multi_by_cursor(db, cursor=None, limit=100, schema_to_select=None, sort_column='id', sort_order='asc', **kwargs)</code>  <code>async</code>","text":"<p>Fetch multiple records based on a cursor for pagination, with optional sorting.</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>AsyncSession</code> <p>The SQLAlchemy async session.</p> required <code>cursor</code> <code>Any</code> <p>The cursor value to start fetching records from. Defaults to None.</p> <code>None</code> <code>limit</code> <code>int</code> <p>Maximum number of rows to fetch.</p> <code>100</code> <code>schema_to_select</code> <code>Optional[type[BaseModel]]</code> <p>Pydantic schema for selecting specific columns.</p> <code>None</code> <code>sort_column</code> <code>str</code> <p>Column name to use for sorting and cursor pagination.</p> <code>'id'</code> <code>sort_order</code> <code>str</code> <p>Sorting direction, either 'asc' or 'desc'.</p> <code>'asc'</code> <code>**kwargs</code> <code>Any</code> <p>Additional filters to apply to the query.</p> <code>{}</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>A dictionary containing the fetched rows under 'data' key and the next cursor value under 'next_cursor'.</p> Usage Examples Note <p>This method is designed for efficient pagination in large datasets and is ideal for infinite scrolling features. Make sure the column used for cursor pagination is indexed for performance. This method assumes that your records can be ordered by a unique, sequential field (like <code>id</code> or <code>created_at</code>).</p> Source code in <code>fastcrud/crud/fast_crud.py</code> <pre><code>async def get_multi_by_cursor(\n    self,\n    db: AsyncSession,\n    cursor: Any = None,\n    limit: int = 100,\n    schema_to_select: Optional[type[BaseModel]] = None,\n    sort_column: str = \"id\",\n    sort_order: str = \"asc\",\n    **kwargs: Any,\n) -&gt; dict[str, Any]:\n    \"\"\"\n    Fetch multiple records based on a cursor for pagination, with optional sorting.\n\n    Args:\n        db: The SQLAlchemy async session.\n        cursor: The cursor value to start fetching records from. Defaults to None.\n        limit: Maximum number of rows to fetch.\n        schema_to_select: Pydantic schema for selecting specific columns.\n        sort_column: Column name to use for sorting and cursor pagination.\n        sort_order: Sorting direction, either 'asc' or 'desc'.\n        **kwargs: Additional filters to apply to the query.\n\n    Returns:\n        A dictionary containing the fetched rows under 'data' key and the next cursor value under 'next_cursor'.\n\n    Usage Examples:\n        # Fetch the first set of records (e.g., the first page in an infinite scrolling scenario)\n        &gt;&gt;&gt; first_page = await crud.get_multi_by_cursor(db, limit=10, sort_column='created_at', sort_order='desc')\n\n        # Fetch the next set of records using the cursor from the first page\n        &gt;&gt;&gt; next_cursor = first_page['next_cursor']\n        &gt;&gt;&gt; second_page = await crud.get_multi_by_cursor(db, cursor=next_cursor, limit=10, sort_column='created_at', sort_order='desc')\n\n    Note:\n        This method is designed for efficient pagination in large datasets and is ideal for infinite scrolling features.\n        Make sure the column used for cursor pagination is indexed for performance.\n        This method assumes that your records can be ordered by a unique, sequential field (like `id` or `created_at`).\n    \"\"\"\n    if limit == 0:\n        return {\"data\": [], \"next_cursor\": None}\n\n    to_select = _extract_matching_columns_from_schema(self.model, schema_to_select)\n    stmt = select(*to_select).filter_by(**kwargs)\n\n    if cursor:\n        if sort_order == \"asc\":\n            stmt = stmt.where(getattr(self.model, sort_column) &gt; cursor)\n        else:\n            stmt = stmt.where(getattr(self.model, sort_column) &lt; cursor)\n\n    stmt = stmt.order_by(\n        asc(getattr(self.model, sort_column))\n        if sort_order == \"asc\"\n        else desc(getattr(self.model, sort_column))\n    )\n    stmt = stmt.limit(limit)\n\n    result = await db.execute(stmt)\n    data = [dict(row) for row in result.mappings()]\n\n    next_cursor = None\n    if len(data) == limit:\n        next_cursor = data[-1][sort_column]\n\n    return {\"data\": data, \"next_cursor\": next_cursor}\n</code></pre>"},{"location":"api/fastcrud/#fastcrud.FastCRUD.get_multi_by_cursor--fetch-the-first-set-of-records-eg-the-first-page-in-an-infinite-scrolling-scenario","title":"Fetch the first set of records (e.g., the first page in an infinite scrolling scenario)","text":"<p>first_page = await crud.get_multi_by_cursor(db, limit=10, sort_column='created_at', sort_order='desc')</p>"},{"location":"api/fastcrud/#fastcrud.FastCRUD.get_multi_by_cursor--fetch-the-next-set-of-records-using-the-cursor-from-the-first-page","title":"Fetch the next set of records using the cursor from the first page","text":"<p>next_cursor = first_page['next_cursor'] second_page = await crud.get_multi_by_cursor(db, cursor=next_cursor, limit=10, sort_column='created_at', sort_order='desc')</p>"},{"location":"api/fastcrud/#fastcrud.FastCRUD.get_multi_joined","title":"<code>get_multi_joined(db, join_model, join_prefix=None, join_on=None, schema_to_select=None, join_schema_to_select=None, join_type='left', offset=0, limit=100, sort_columns=None, sort_orders=None, return_as_model=False, **kwargs)</code>  <code>async</code>","text":"<p>Fetch multiple records with a join on another model, allowing for pagination, optional sorting, and model conversion.</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>AsyncSession</code> <p>The SQLAlchemy async session.</p> required <code>join_model</code> <code>type[ModelType]</code> <p>The model to join with.</p> required <code>join_prefix</code> <code>Optional[str]</code> <p>Optional prefix to be added to all columns of the joined model. If None, no prefix is added.</p> <code>None</code> <code>join_on</code> <code>Optional[Join]</code> <p>SQLAlchemy Join object for specifying the ON clause of the join. If None, the join condition is auto-detected based on foreign keys.</p> <code>None</code> <code>schema_to_select</code> <code>Optional[type[BaseModel]]</code> <p>Pydantic schema for selecting specific columns from the primary model.</p> <code>None</code> <code>join_schema_to_select</code> <code>Optional[type[BaseModel]]</code> <p>Pydantic schema for selecting specific columns from the joined model.</p> <code>None</code> <code>join_type</code> <code>str</code> <p>Specifies the type of join operation to perform. Can be \"left\" for a left outer join or \"inner\" for an inner join.</p> <code>'left'</code> <code>offset</code> <code>int</code> <p>The offset (number of records to skip) for pagination.</p> <code>0</code> <code>limit</code> <code>int</code> <p>The limit (maximum number of records to return) for pagination.</p> <code>100</code> <code>sort_columns</code> <code>Optional[Union[str, list[str]]]</code> <p>A single column name or a list of column names on which to apply sorting.</p> <code>None</code> <code>sort_orders</code> <code>Optional[Union[str, list[str]]]</code> <p>A single sort order ('asc' or 'desc') or a list of sort orders corresponding to the columns in sort_columns. If not provided, defaults to 'asc' for each column.</p> <code>None</code> <code>return_as_model</code> <code>bool</code> <p>If True, converts the fetched data to Pydantic models based on schema_to_select. Defaults to False.</p> <code>False</code> <code>**kwargs</code> <code>Any</code> <p>Filters to apply to the primary query.</p> <code>{}</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>A dictionary containing the fetched rows under 'data' key and total count under 'total_count'.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If limit or offset is negative, or if schema_to_select is required but not provided or invalid.</p> <p>Examples:</p> <p>Fetching multiple User records joined with Tier records, using left join, returning raw data:</p> <pre><code>&gt;&gt;&gt; users = await crud_user.get_multi_joined(\n        db=session,\n        join_model=Tier,\n        join_prefix=\"tier_\",\n        schema_to_select=UserSchema,\n        join_schema_to_select=TierSchema,\n        offset=0,\n        limit=10\n    )\n</code></pre> <p>Fetching and sorting by username in descending order, returning as Pydantic model:</p> <pre><code>&gt;&gt;&gt; users = await crud_user.get_multi_joined(\n        db=session,\n        join_model=Tier,\n        join_prefix=\"tier_\",\n        schema_to_select=UserSchema,\n        join_schema_to_select=TierSchema,\n        offset=0,\n        limit=10,\n        sort_columns=['username'],\n        sort_orders=['desc'],\n        return_as_model=True\n    )\n</code></pre> <p>Fetching with complex conditions and custom join, returning as Pydantic model:</p> <pre><code>&gt;&gt;&gt; users = await crud_user.get_multi_joined(\n        db=session,\n        join_model=Tier,\n        join_prefix=\"tier_\",\n        join_on=User.tier_id == Tier.id,\n        schema_to_select=UserSchema,\n        join_schema_to_select=TierSchema,\n        offset=0,\n        limit=10,\n        is_active=True,\n        return_as_model=True\n    )\n</code></pre> Source code in <code>fastcrud/crud/fast_crud.py</code> <pre><code>async def get_multi_joined(\n    self,\n    db: AsyncSession,\n    join_model: type[ModelType],\n    join_prefix: Optional[str] = None,\n    join_on: Optional[Join] = None,\n    schema_to_select: Optional[type[BaseModel]] = None,\n    join_schema_to_select: Optional[type[BaseModel]] = None,\n    join_type: str = \"left\",\n    offset: int = 0,\n    limit: int = 100,\n    sort_columns: Optional[Union[str, list[str]]] = None,\n    sort_orders: Optional[Union[str, list[str]]] = None,\n    return_as_model: bool = False,\n    **kwargs: Any,\n) -&gt; dict[str, Any]:\n    \"\"\"\n    Fetch multiple records with a join on another model, allowing for pagination, optional sorting, and model conversion.\n\n    Args:\n        db: The SQLAlchemy async session.\n        join_model: The model to join with.\n        join_prefix: Optional prefix to be added to all columns of the joined model. If None, no prefix is added.\n        join_on: SQLAlchemy Join object for specifying the ON clause of the join. If None, the join condition is auto-detected based on foreign keys.\n        schema_to_select: Pydantic schema for selecting specific columns from the primary model.\n        join_schema_to_select: Pydantic schema for selecting specific columns from the joined model.\n        join_type: Specifies the type of join operation to perform. Can be \"left\" for a left outer join or \"inner\" for an inner join.\n        offset: The offset (number of records to skip) for pagination.\n        limit: The limit (maximum number of records to return) for pagination.\n        sort_columns: A single column name or a list of column names on which to apply sorting.\n        sort_orders: A single sort order ('asc' or 'desc') or a list of sort orders corresponding to the columns in sort_columns. If not provided, defaults to 'asc' for each column.\n        return_as_model: If True, converts the fetched data to Pydantic models based on schema_to_select. Defaults to False.\n        **kwargs: Filters to apply to the primary query.\n\n    Returns:\n        A dictionary containing the fetched rows under 'data' key and total count under 'total_count'.\n\n    Raises:\n        ValueError: If limit or offset is negative, or if schema_to_select is required but not provided or invalid.\n\n    Examples:\n        Fetching multiple User records joined with Tier records, using left join, returning raw data:\n        &gt;&gt;&gt; users = await crud_user.get_multi_joined(\n                db=session,\n                join_model=Tier,\n                join_prefix=\"tier_\",\n                schema_to_select=UserSchema,\n                join_schema_to_select=TierSchema,\n                offset=0,\n                limit=10\n            )\n\n        Fetching and sorting by username in descending order, returning as Pydantic model:\n        &gt;&gt;&gt; users = await crud_user.get_multi_joined(\n                db=session,\n                join_model=Tier,\n                join_prefix=\"tier_\",\n                schema_to_select=UserSchema,\n                join_schema_to_select=TierSchema,\n                offset=0,\n                limit=10,\n                sort_columns=['username'],\n                sort_orders=['desc'],\n                return_as_model=True\n            )\n\n        Fetching with complex conditions and custom join, returning as Pydantic model:\n        &gt;&gt;&gt; users = await crud_user.get_multi_joined(\n                db=session,\n                join_model=Tier,\n                join_prefix=\"tier_\",\n                join_on=User.tier_id == Tier.id,\n                schema_to_select=UserSchema,\n                join_schema_to_select=TierSchema,\n                offset=0,\n                limit=10,\n                is_active=True,\n                return_as_model=True\n            )\n    \"\"\"\n    if limit &lt; 0 or offset &lt; 0:\n        raise ValueError(\"Limit and offset must be non-negative.\")\n\n    if join_on is None:\n        join_on = _auto_detect_join_condition(self.model, join_model)\n\n    primary_select = _extract_matching_columns_from_schema(\n        model=self.model, schema=schema_to_select\n    )\n    join_select = []\n\n    if join_schema_to_select:\n        columns = _extract_matching_columns_from_schema(\n            model=join_model, schema=join_schema_to_select\n        )\n    else:\n        columns = inspect(join_model).c\n\n    for column in columns:\n        labeled_column = _add_column_with_prefix(column, join_prefix)\n        if f\"{join_prefix}{column.name}\" not in [\n            col.name for col in primary_select\n        ]:\n            join_select.append(labeled_column)\n\n    if join_type == \"left\":\n        stmt = select(*primary_select, *join_select).outerjoin(join_model, join_on)\n    elif join_type == \"inner\":\n        stmt = select(*primary_select, *join_select).join(join_model, join_on)\n    else:\n        raise ValueError(\n            f\"Invalid join type: {join_type}. Only 'left' or 'inner' are valid.\"\n        )\n\n    for key, value in kwargs.items():\n        if hasattr(self.model, key):\n            stmt = stmt.where(getattr(self.model, key) == value)\n\n    if sort_columns:\n        stmt = self._apply_sorting(stmt, sort_columns, sort_orders)\n\n    stmt = stmt.offset(offset).limit(limit)\n\n    db_rows = await db.execute(stmt)\n    data = [dict(row._mapping) for row in db_rows]\n\n    if return_as_model and schema_to_select:\n        data = [schema_to_select.model_construct(**row) for row in data]\n\n    total_count = await self.count(db=db, **kwargs)\n\n    return {\"data\": data, \"total_count\": total_count}\n</code></pre>"},{"location":"api/fastcrud/#fastcrud.FastCRUD.update","title":"<code>update(db, object, **kwargs)</code>  <code>async</code>","text":"<p>Update an existing record in the database.</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>AsyncSession</code> <p>The SQLAlchemy async session.</p> required <code>object</code> <code>Union[UpdateSchemaType, dict[str, Any]]</code> <p>The Pydantic schema or dictionary containing the data to be updated.</p> required <code>**kwargs</code> <code>Any</code> <p>Filters for the update.</p> <code>{}</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If extra fields not present in the model are provided in the update data.</p> Source code in <code>fastcrud/crud/fast_crud.py</code> <pre><code>async def update(\n    self,\n    db: AsyncSession,\n    object: Union[UpdateSchemaType, dict[str, Any]],\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"\n    Update an existing record in the database.\n\n    Args:\n        db: The SQLAlchemy async session.\n        object: The Pydantic schema or dictionary containing the data to be updated.\n        **kwargs: Filters for the update.\n\n    Returns:\n        None\n\n    Raises:\n        ValueError: If extra fields not present in the model are provided in the update data.\n    \"\"\"\n    if isinstance(object, dict):\n        update_data = object\n    else:\n        update_data = object.model_dump(exclude_unset=True)\n\n    if \"updated_at\" in update_data.keys():\n        update_data[\"updated_at\"] = datetime.now(timezone.utc)\n\n    model_columns = {column.name for column in inspect(self.model).c}\n    extra_fields = set(update_data) - model_columns\n    if extra_fields:\n        raise ValueError(f\"Extra fields provided: {extra_fields}\")\n\n    stmt = update(self.model).filter_by(**kwargs).values(update_data)\n\n    await db.execute(stmt)\n    await db.commit()\n</code></pre>"},{"location":"api/overview/","title":"API Reference Overview","text":"<p>Welcome to the API Reference section of our documentation. This section provides detailed information about the various classes, functions, and modules that make up our application. Whether you are looking to extend the application, integrate with it, or simply explore its capabilities, this section will guide you through the intricacies of our codebase.</p>"},{"location":"api/overview/#key-components","title":"Key Components","text":"<p>Our application's API is comprised of several key components, each serving a specific purpose:</p> <ol> <li> <p>FastCRUD Class: This class is at the heart of our CRUD (Create, Read, Update, Delete) operations. It provides a convenient and efficient way to interact with our database models.</p> <ul> <li>FastCRUD Class Reference</li> </ul> </li> <li> <p>EndpointCreator Class: A utility class for creating and registering CRUD endpoints in a FastAPI application. It simplifies the addition of standard CRUD endpoints to your FastAPI router.</p> <ul> <li>EndpointCreator Class Reference</li> </ul> </li> <li> <p>crud_router Function: A function that creates and configures a FastAPI router with CRUD endpoints for a specific model. It's a quick way to add standard CRUD operations to your models.</p> <ul> <li>CRUD Router Function Reference</li> </ul> </li> </ol>"},{"location":"api/overview/#usage","title":"Usage","text":"<p>Each component is documented with its own dedicated page, where you can find detailed information about its methods, parameters, return types, and usage examples. These pages are designed to provide you with all the information you need to understand and work with our API effectively.</p>"},{"location":"api/overview/#contribution","title":"Contribution","text":"<p>If you wish to contribute to the development of our API, please refer to our Contributing Guidelines. We welcome contributions of all forms, from bug fixes to feature development.</p>"},{"location":"api/overview/#feedback","title":"Feedback","text":"<p>Your feedback is crucial in helping us improve this documentation. If you have any suggestions, corrections, or queries, please reach out to us.</p> <p>Navigate through each section for detailed documentation of our API components.</p>"},{"location":"community/CODE_OF_CONDUCT/","title":"Contributor Covenant Code of Conduct","text":""},{"location":"community/CODE_OF_CONDUCT/#our-pledge","title":"Our Pledge","text":"<p>We as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.</p> <p>We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community.</p>"},{"location":"community/CODE_OF_CONDUCT/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to a positive environment for our community include:</p> <ul> <li>Demonstrating empathy and kindness toward other people</li> <li>Being respectful of differing opinions, viewpoints, and experiences</li> <li>Giving and gracefully accepting constructive feedback</li> <li>Accepting responsibility and apologizing to those affected by our mistakes,   and learning from the experience</li> <li>Focusing on what is best not just for us as individuals, but for the   overall community</li> </ul> <p>Examples of unacceptable behavior include:</p> <ul> <li>The use of sexualized language or imagery, and sexual attention or   advances of any kind</li> <li>Trolling, insulting or derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or email   address, without their explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a   professional setting</li> </ul>"},{"location":"community/CODE_OF_CONDUCT/#enforcement-responsibilities","title":"Enforcement Responsibilities","text":"<p>Community leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful.</p> <p>Community leaders have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for moderation decisions when appropriate.</p>"},{"location":"community/CODE_OF_CONDUCT/#scope","title":"Scope","text":"<p>This Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces. Examples of representing our community include using an official e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event.</p>"},{"location":"community/CODE_OF_CONDUCT/#enforcement","title":"Enforcement","text":"<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported to the community leaders responsible for enforcement at igor.magalhaes.r@gmail.com. All complaints will be reviewed and investigated promptly and fairly.</p> <p>All community leaders are obligated to respect the privacy and security of the reporter of any incident.</p>"},{"location":"community/CODE_OF_CONDUCT/#enforcement-guidelines","title":"Enforcement Guidelines","text":"<p>Community leaders will follow these Community Impact Guidelines in determining the consequences for any action they deem in violation of this Code of Conduct:</p>"},{"location":"community/CODE_OF_CONDUCT/#1-correction","title":"1. Correction","text":"<p>Community Impact: Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community.</p> <p>Consequence: A private, written warning from community leaders, providing clarity around the nature of the violation and an explanation of why the behavior was inappropriate. A public apology may be requested.</p>"},{"location":"community/CODE_OF_CONDUCT/#2-warning","title":"2. Warning","text":"<p>Community Impact: A violation through a single incident or series of actions.</p> <p>Consequence: A warning with consequences for continued behavior. No interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, for a specified period of time. This includes avoiding interactions in community spaces as well as external channels like social media. Violating these terms may lead to a temporary or permanent ban.</p>"},{"location":"community/CODE_OF_CONDUCT/#3-temporary-ban","title":"3. Temporary Ban","text":"<p>Community Impact: A serious violation of community standards, including sustained inappropriate behavior.</p> <p>Consequence: A temporary ban from any sort of interaction or public communication with the community for a specified period of time. No public or private interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, is allowed during this period. Violating these terms may lead to a permanent ban.</p>"},{"location":"community/CODE_OF_CONDUCT/#4-permanent-ban","title":"4. Permanent Ban","text":"<p>Community Impact: Demonstrating a pattern of violation of community standards, including sustained inappropriate behavior,  harassment of an individual, or aggression toward or disparagement of classes of individuals.</p> <p>Consequence: A permanent ban from any sort of public interaction within the community.</p>"},{"location":"community/CODE_OF_CONDUCT/#attribution","title":"Attribution","text":"<p>This Code of Conduct is adapted from the Contributor Covenant, version 2.0, available at https://www.contributor-covenant.org/version/2/0/code_of_conduct.html.</p> <p>Community Impact Guidelines were inspired by Mozilla's code of conduct enforcement ladder.</p> <p>For answers to common questions about this code of conduct, see the FAQ at https://www.contributor-covenant.org/faq. Translations are available at https://www.contributor-covenant.org/translations.</p>"},{"location":"community/CONTRIBUTING/","title":"Contributing to FastAPI-boilerplate","text":"<p>Thank you for your interest in contributing to FastAPI-boilerplate! This guide is meant to make it easy for you to get started. Contributions are appreciated, even if just reporting bugs, documenting stuff or answering questions. To contribute with a feature:</p>"},{"location":"community/CONTRIBUTING/#setting-up-your-development-environment","title":"Setting Up Your Development Environment","text":""},{"location":"community/CONTRIBUTING/#cloning-the-repository","title":"Cloning the Repository","text":"<p>Start by forking and cloning the FastAPI-boilerplate repository:</p> <ol> <li>Fork the Repository: Begin by forking the project repository. You can do this by visiting https://github.com/igormagalhaesr/FastAPI-boilerplate and clicking the \"Fork\" button.</li> <li>Create a Feature Branch: Once you've forked the repo, create a branch for your feature by running <code>git checkout -b feature/fooBar</code>.</li> <li>Testing Changes: Ensure that your changes do not break existing functionality by running tests. In the root folder, execute poetry run <code>python -m pytest</code> to run the tests.</li> </ol>"},{"location":"community/CONTRIBUTING/#using-poetry-for-dependency-management","title":"Using Poetry for Dependency Management","text":"<p>FastAPI-boilerplate uses Poetry for managing dependencies. If you don't have Poetry installed, follow the instructions on the official Poetry website.</p> <p>Once Poetry is installed, navigate to the cloned repository and install the dependencies: <pre><code>cd FastAPI-boilerplate\npoetry install\n</code></pre></p>"},{"location":"community/CONTRIBUTING/#activating-the-virtual-environment","title":"Activating the Virtual Environment","text":"<p>Poetry creates a virtual environment for your project. Activate it using:</p> <pre><code>poetry shell\n</code></pre>"},{"location":"community/CONTRIBUTING/#making-contributions","title":"Making Contributions","text":""},{"location":"community/CONTRIBUTING/#coding-standards","title":"Coding Standards","text":"<ul> <li>Follow PEP 8 guidelines.</li> <li>Write meaningful tests for new features or bug fixes.</li> </ul>"},{"location":"community/CONTRIBUTING/#testing-with-pytest","title":"Testing with Pytest","text":"<p>FastAPI-boilerplate uses pytest for testing. Run tests using: <pre><code>poetry run pytest\n</code></pre></p>"},{"location":"community/CONTRIBUTING/#linting","title":"Linting","text":"<p>Use mypy for type checking: <pre><code>mypy src\n</code></pre></p> <p>Use ruff for style: <pre><code>ruff check --fix\nruff format\n</code></pre></p> <p>Ensure your code passes linting before submitting.</p>"},{"location":"community/CONTRIBUTING/#using-pre-commit-for-better-code-quality","title":"Using pre-commit for Better Code Quality","text":"<p>It helps in identifying simple issues before submission to code review. By running automated checks, pre-commit can ensure code quality and consistency.</p> <ol> <li>Install Pre-commit:</li> <li>Installation: Install pre-commit in your development environment. Use the command <code>pip install pre-commit</code>.</li> <li>Setting Up Hooks: After installing pre-commit, set up the hooks with <code>pre-commit install</code>. This command will install hooks into your .git/ directory which will automatically check your commits for issues.</li> <li>Committing Your Changes:    After making your changes, use <code>git commit -am 'Add some fooBar'</code> to commit them. Pre-commit will run automatically on your files when you commit, ensuring that they meet the required standards.    Note: If pre-commit identifies issues, it may block your commit. Fix these issues and commit again. This ensures that all contributions are of high quality.</li> <li>Pushing Changes and Creating Pull Request:    Push your changes to the branch using <code>git push origin feature/fooBar</code>.    Visit your fork on GitHub and create a new Pull Request to the main repository.</li> </ol>"},{"location":"community/CONTRIBUTING/#additional-notes","title":"Additional Notes","text":"<p>Stay Updated: Keep your fork updated with the main repository to avoid merge conflicts. Regularly fetch and merge changes from the upstream repository. Adhere to Project Conventions: Follow the coding style, conventions, and commit message guidelines of the project. Open Communication: Feel free to ask questions or discuss your ideas by opening an issue or in discussions.</p>"},{"location":"community/CONTRIBUTING/#submitting-your-contributions","title":"Submitting Your Contributions","text":""},{"location":"community/CONTRIBUTING/#creating-a-pull-request","title":"Creating a Pull Request","text":"<p>After making your changes:</p> <ul> <li>Push your changes to your fork.</li> <li>Open a pull request with a clear description of your changes.</li> <li>Update the README.md if necessary.</li> </ul>"},{"location":"community/CONTRIBUTING/#code-reviews","title":"Code Reviews","text":"<ul> <li>Address any feedback from code reviews.</li> <li>Once approved, your contributions will be merged into the main branch.</li> </ul>"},{"location":"community/CONTRIBUTING/#code-of-conduct","title":"Code of Conduct","text":"<p>Please adhere to our Code of Conduct to maintain a welcoming and inclusive environment.</p> <p>Thank you for contributing to FastAPI-boilerplate\ud83d\ude80</p>"},{"location":"community/LICENSE/","title":"License","text":"<p>MIT License</p> <p>Copyright (c) 2023 Igor Magalh\u00e3es</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"community/overview/","title":"Community Overview","text":"<p>Welcome to the project's community hub. Here, you'll find essential resources and guidelines that are crucial for contributing to and participating in the project. Please take the time to familiarize yourself with the following documents:</p>"},{"location":"community/overview/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Contributing</li> <li>Code of Conduct</li> <li>License</li> </ul>"},{"location":"community/overview/#contributing","title":"Contributing","text":"<p>View the Contributing Guidelines</p> <p>Interested in contributing to the project? Great! The contributing guidelines will provide you with all the information you need to get started. This includes how to submit issues, propose changes, and the process for submitting pull requests.</p>"},{"location":"community/overview/#code-of-conduct","title":"Code of Conduct","text":"<p>View the Code of Conduct</p> <p>The Code of Conduct outlines the standards and behaviors expected of our community members. It's crucial to ensure a welcoming and inclusive environment for everyone. Please take the time to read and adhere to these guidelines.</p>"},{"location":"community/overview/#license","title":"License","text":"<p>View the License</p> <p>The license document outlines the terms under which our project can be used, modified, and distributed. Understanding the licensing is important for both users and contributors of the project.</p> <p>Thank you for being a part of our community and for contributing to our project's success!</p>"},{"location":"usage/crud/","title":"Using FastCRUD for Enhanced CRUD Operations","text":"<p>FastCRUD is a versatile tool for handling CRUD (Create, Read, Update, Delete) operations in FastAPI applications with SQLAlchemy models. It leverages Pydantic schemas for data validation and serialization, offering a streamlined approach to database interactions.</p>"},{"location":"usage/crud/#key-features","title":"Key Features","text":"<ul> <li>Simplified CRUD operations with SQLAlchemy models.</li> <li>Data validation and serialization using Pydantic.</li> <li>Support for complex queries including joins and pagination.</li> </ul>"},{"location":"usage/crud/#getting-started","title":"Getting Started","text":""},{"location":"usage/crud/#step-1-define-models-and-schemas","title":"Step 1: Define Models and Schemas","text":"<p>Define your SQLAlchemy models and Pydantic schemas for data representation.</p> <pre><code># SQLAlchemy models and Pydantic schema definitions\n</code></pre>"},{"location":"usage/crud/#step-2-initialize-fastcrud","title":"Step 2: Initialize FastCRUD","text":"<p>Create a FastCRUD instance for your model to handle CRUD operations.</p> <pre><code>from fastcrud import FastCRUD\n\n# Creating a FastCRUD instance\nmy_model_crud = FastCRUD(MyModel)\n</code></pre>"},{"location":"usage/crud/#step-3-pick-your-method","title":"Step 3: Pick your Method","text":"<p>Then you just pick the method you need and use it like this:</p> <pre><code># Creating a new record\nnew_record = await my_model_crud.create(db_session, create_schema_instance)\n</code></pre> <p>More on available methods below.</p>"},{"location":"usage/crud/#understanding-fastcrud-methods","title":"Understanding FastCRUD Methods","text":"<p>FastCRUD offers a comprehensive suite of methods for CRUD operations, each designed to handle different aspects of database interactions efficiently.</p>"},{"location":"usage/crud/#1-create","title":"1. Create","text":"<pre><code>create(\n    db: AsyncSession, \n    object: CreateSchemaType\n) -&gt; ModelType\n</code></pre> <p>Purpose: To create a new record in the database. Usage Example: Creates an item with name 'New Item'.</p> <pre><code>new_item = await item_crud.create(db, ItemCreateSchema(name=\"New Item\"))\n</code></pre>"},{"location":"usage/crud/#2-get","title":"2. Get","text":"<pre><code>get(\n    db: AsyncSession, \n    schema_to_select: Optional[type[BaseModel]] = None,\n    **kwargs: Any\n) -&gt; Optional[dict]\n</code></pre> <p>Purpose: To fetch a single record based on filters, with an option to select specific columns using a Pydantic schema. Usage Example: Fetches the item with item_id as its id.</p> <pre><code>item = await item_crud.get(db, id=item_id)\n</code></pre>"},{"location":"usage/crud/#3-exists","title":"3. Exists","text":"<pre><code>exists(\n    db: AsyncSession, \n    **kwargs: Any\n) -&gt; bool\n</code></pre> <p>Purpose: To check if a record exists based on provided filters. Usage Example: Checks whether an item with name 'Existing Item' exists.</p> <pre><code>exists = await item_crud.exists(db, name=\"Existing Item\")\n</code></pre>"},{"location":"usage/crud/#4-count","title":"4. Count","text":"<pre><code>count(\n    db: AsyncSession, \n    **kwargs: Any\n) -&gt; int\n</code></pre> <p>Purpose: To count the number of records matching provided filters. Usage Example: Counts the number of items with the 'Books' category.</p> <pre><code>count = await item_crud.count(db, category=\"Books\")\n</code></pre>"},{"location":"usage/crud/#5-get-multi","title":"5. Get Multi","text":"<pre><code>get_multi(\n    db: AsyncSession, \n    offset: int = 0, \n    limit: int = 100, \n    schema_to_select: Optional[type[BaseModel]] = None, \n    sort_columns: Optional[Union[str, list[str]]] = None, \n    sort_orders: Optional[Union[str, list[str]]] = None, \n    return_as_model: bool = False, \n    **kwargs: Any\n) -&gt; dict[str, Any]&lt;/\n</code></pre> <p>Purpose: To fetch multiple records with optional sorting, pagination, and model conversion. Usage Example: Fetches a subset of 5 items, starting from the 11th item in the database.</p> <pre><code>items = await item_crud.get_multi(db, offset=10, limit=5)\n</code></pre>"},{"location":"usage/crud/#6-update","title":"6. Update","text":"<pre><code>update(\n    db: AsyncSession, \n    object: Union[UpdateSchemaType, dict[str, Any]], \n    **kwargs: Any\n) -&gt; None\n</code></pre> <p>Purpose: To update an existing record in the database. Usage Example: Updates the description of the item with item_id as its id.</p> <pre><code>await item_crud.update(db, ItemUpdateSchema(description=\"Updated\"), id=item_id)\n</code></pre>"},{"location":"usage/crud/#7-delete","title":"7. Delete","text":"<pre><code>delete(\n    db: AsyncSession, \n    db_row: Optional[Row] = None, \n    **kwargs: Any\n) -&gt; None\n</code></pre> <p>Purpose: To delete a record from the database, with support for soft delete. Usage Example: Deletes the item with item_id as its id, performs a soft delete if the model has the 'is_deleted' column.</p> <pre><code>await item_crud.delete(db, id=item_id)\n</code></pre>"},{"location":"usage/crud/#8-hard-delete","title":"8. Hard Delete","text":"<pre><code>db_delete(\n    db: AsyncSession, \n    **kwargs: Any\n) -&gt; None\n</code></pre> <p>Purpose: To hard delete a record from the database. Usage Example: Hard deletes the item with item_id as its id.</p> <pre><code>await item_crud.db_delete(db, id=item_id)\n</code></pre>"},{"location":"usage/crud/#advanced-methods-for-complex-queries-and-joins","title":"Advanced Methods for Complex Queries and Joins","text":"<p>FastCRUD extends its functionality with advanced methods tailored for complex query operations and handling joins. These methods cater to specific use cases where more sophisticated data retrieval and manipulation are required.</p>"},{"location":"usage/crud/#1-get-multi","title":"1. Get Multi","text":"<pre><code>get_multi(\n    db: AsyncSession, \n    offset: int = 0, \n    limit: int = 100, \n    schema_to_select: Optional[type[BaseModel]] = None, \n    sort_columns: Optional[Union[str, list[str]]] = None, \n    sort_orders: Optional[Union[str, list[str]]] = None, \n    return_as_model: bool = False, \n    **kwargs: Any\n) -&gt; dict[str, Any]\n</code></pre> <p>Purpose: To fetch multiple records based on specified filters, with options for sorting and pagination. Usage Example: Gets the first 10 items sorted by 'name' in ascending order.</p> <pre><code>items = await item_crud.get_multi(db, offset=0, limit=10, sort_columns=['name'], sort_orders=['asc'])\n</code></pre>"},{"location":"usage/crud/#2-get-joined","title":"2. Get Joined","text":"<pre><code>get_joined(\n    db: AsyncSession, \n    join_model: type[ModelType], \n    join_prefix: Optional[str] = None, \n    join_on: Optional[Union[Join, None]] = None, \n    schema_to_select: Optional[type[BaseModel]] = None, \n    join_schema_to_select: Optional[type[BaseModel]] = None, \n    join_type: str = \"left\", **kwargs: Any\n) -&gt; Optional[dict[str, Any]]\n</code></pre> <p>Purpose: To fetch a single record while performing a join operation with another model. Usage Example: Fetches order details for a specific order by joining with the Customer table, selecting specific columns as defined in OrderSchema and CustomerSchema.</p> <pre><code>order_details = await order_crud.get_joined(\n    db, \n    join_model=Customer, \n    schema_to_select=OrderSchema, \n    join_schema_to_select=CustomerSchema, \n    id=order_id\n)\n</code></pre>"},{"location":"usage/crud/#3-get-multi-joined","title":"3. Get Multi Joined","text":"<pre><code>get_multi_joined(\n    db: AsyncSession, \n    join_model: type[ModelType], \n    join_prefix: Optional[str] = None, \n    join_on: Optional[Join] = None, \n    schema_to_select: Optional[type[BaseModel]] = None, \n    join_schema_to_select: Optional[type[BaseModel]] = None, \n    join_type: str = \"left\", \n    offset: int = 0, \n    limit: int = 100, \n    sort_columns: Optional[Union[str, list[str]]] = None, \n    sort_orders: Optional[Union[str, list[str]]] = None, \n    return_as_model: bool = False, \n    **kwargs: Any\n) -&gt; dict[str, Any]\n</code></pre> <p>Purpose: Similar to <code>get_joined</code>, but for fetching multiple records. Usage Example: Retrieves a paginated list of orders (up to 5), joined with the Customer table, using specified schemas for selective column retrieval from both tables.</p> <pre><code>orders = await order_crud.get_multi_joined(\n    db, \n    join_model=Customer, \n    offset=0, \n    limit=5, \n    schema_to_select=OrderSchema, \n    join_schema_to_select=CustomerSchema\n)\n</code></pre>"},{"location":"usage/crud/#4-get-multi-by-cursor","title":"4. Get Multi By Cursor","text":"<pre><code>get_multi_by_cursor(\n    db: AsyncSession, \n    cursor: Any = None, \n    limit: int = 100, \n    schema_to_select: Optional[type[BaseModel]] = None, \n    sort_column: str = \"id\", \n    sort_order: str = \"asc\", \n    **kwargs: Any\n) -&gt; dict[str, Any]\n</code></pre> <p>Purpose: Implements cursor-based pagination for efficient data retrieval in large datasets. Usage Example: Fetches the next 10 items after the last cursor for efficient pagination, sorted by creation date in descending order.</p> <pre><code>paginated_items = await item_crud.get_multi_by_cursor(\n    db, \n    cursor=last_cursor, \n    limit=10, \n    sort_column='created_at', \n    sort_order='desc'\n)\n</code></pre>"},{"location":"usage/crud/#error-handling","title":"Error Handling","text":"<p>FastCRUD provides mechanisms to handle common database errors, ensuring robust API behavior.</p>"},{"location":"usage/endpoint/","title":"Automatic Endpoint Creation with crud_router","text":"<p>This section of the documentation explains how to use the <code>crud_router</code> utility function from the FastCRUD package for automatic endpoint creation in a FastAPI application. The <code>crud_router</code> simplifies the process of creating standard CRUD (Create, Read, Update, Delete) endpoints for your models.</p>"},{"location":"usage/endpoint/#prerequisites","title":"Prerequisites","text":"<p>Before proceeding, ensure you have FastAPI and FastCRUD installed in your environment. FastCRUD streamlines interactions with the database using SQLAlchemy models and Pydantic schemas.</p> <p>Warning</p> <pre><code>For now, your primary column in the database model must be named `id`.\n</code></pre>"},{"location":"usage/endpoint/#using-crud_router","title":"Using <code>crud_router</code>","text":""},{"location":"usage/endpoint/#step-1-define-your-model-and-schema","title":"Step 1: Define Your Model and Schema","text":"<p>First, define your SQLAlchemy model and corresponding Pydantic schemas for creating and updating data.</p> models/item.py<pre><code>from sqlalchemy import Column, Integer, String\nfrom sqlalchemy.orm import DeclarativeBase\nfrom pydantic import BaseModel\n\nclass Base(DeclarativeBase):\n    pass\n\nclass Item(Base):\n    __tablename__ = 'items'\n    id = Column(Integer, primary_key=True)\n    name = Column(String)\n    description = Column(String)\n\nclass ItemCreateSchema(BaseModel):\n    name: str\n    description: str\n\nclass ItemUpdateSchema(BaseModel):\n    name: str\n    description: str\n</code></pre>"},{"location":"usage/endpoint/#step-2-set-up-fastapi-and-fastcrud","title":"Step 2: Set Up FastAPI and FastCRUD","text":"<p>Next, set up your FastAPI application and FastCRUD instances. This involves configuring the database connection and creating a CRUD instance for your model.</p> <pre><code>from fastapi import FastAPI\nfrom fastcrud import FastCRUD, crud_router\nfrom sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy.orm import sessionmaker\n\n# Database setup (Async SQLAlchemy)\nDATABASE_URL = \"sqlite+aiosqlite:///./test.db\"\nengine = create_async_engine(DATABASE_URL, echo=True)\nasync_session = sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)\n\n# FastAPI app\napp = FastAPI()\n\n# CRUD operations setup\ncrud = FastCRUD(Item)\n</code></pre>"},{"location":"usage/endpoint/#step-3-use-crud_router-to-create-endpoints","title":"Step 3: Use <code>crud_router</code> to Create Endpoints","text":"<pre><code># CRUD router setup\nitem_router = crud_router(\n    session=async_session,\n    model=Item,\n    crud=crud,\n    create_schema=ItemCreateSchema,\n    update_schema=ItemUpdateSchema,\n    path=\"/items\",\n    tags=[\"Items\"]\n)\n\napp.include_router(item_router)\n</code></pre>"},{"location":"usage/endpoint/#usage-and-testing","title":"Usage and Testing","text":"<p>Once the application is running, you can test the automatically created endpoints using tools like Swagger UI, which FastAPI provides by default. The endpoints for creating, reading, updating, and deleting Item instances are now accessible at /items.</p>"},{"location":"usage/endpoint/#using-endpointcreator-directly","title":"Using <code>EndpointCreator</code> Directly","text":"<p>Using the <code>EndpointCreator</code> class in FastCRUD is a more flexible way to add CRUD endpoints to a FastAPI application.</p>"},{"location":"usage/endpoint/#step-1-define-your-model-and-schema_1","title":"Step 1: Define Your Model and Schema","text":"<p>Define your SQLAlchemy models and corresponding Pydantic schemas for data validation.</p> models/item.py<pre><code>from sqlalchemy import Column, Integer, String\nfrom sqlalchemy.orm import DeclarativeBase\nfrom pydantic import BaseModel\n\nclass Base(DeclarativeBase):\n    pass\n\nclass Item(Base):\n    __tablename__ = 'items'\n    id = Column(Integer, primary_key=True)\n    name = Column(String)\n    description = Column(String)\n\nclass ItemCreateSchema(BaseModel):\n    name: str\n    description: str\n\nclass ItemUpdateSchema(BaseModel):\n    name: str\n    description: str\n</code></pre>"},{"location":"usage/endpoint/#step-2-set-up-fastapi-and-fastcrud_1","title":"Step 2: Set Up FastAPI and FastCRUD","text":"<p>Next, set up your FastAPI application and FastCRUD instances. This involves configuring the database connection and creating a CRUD instance for your model.</p> <pre><code>from fastapi import FastAPI\nfrom fastcrud import FastCRUD, crud_router\nfrom sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy.orm import sessionmaker\n\n# Database setup (Async SQLAlchemy)\nDATABASE_URL = \"sqlite+aiosqlite:///./test.db\"\nengine = create_async_engine(DATABASE_URL, echo=True)\nasync_session = sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)\n\n# FastAPI app\napp = FastAPI()\n\n# CRUD operations setup\ncrud = FastCRUD(Item)\n</code></pre>"},{"location":"usage/endpoint/#step-3-initialize-endpointcreator","title":"Step 3: Initialize <code>EndpointCreator</code>","text":"<p>Create an instance of EndpointCreator by passing the necessary parameters, including your model, session, CRUD instance, and schemas.</p> <pre><code>from fastcrud import EndpointCreator\n\n# Initialize EndpointCreator\nendpoint_creator = EndpointCreator(\n    session=async_session,\n    model=YourModel,\n    crud=your_crud_instance,\n    create_schema=YourCreateSchema,\n    update_schema=YourUpdateSchema,\n    delete_schema=YourDeleteSchema,\n    path=\"/yourmodelpath\",\n    tags=[\"YourModelTag\"]\n)\n</code></pre>"},{"location":"usage/endpoint/#step-4-add-custom-endpoints","title":"Step 4: Add Custom Endpoints","text":"<p>Add custom endpoints using EndpointCreator. You can inject dependencies as needed.</p> <pre><code># Example of adding custom dependencies\nendpoint_creator.add_routes_to_router(\n    read_deps=[custom_dependency],\n    update_deps=[another_custom_dependency]\n)\n</code></pre>"},{"location":"usage/endpoint/#step-5-include-the-router-in-your-application","title":"Step 5: Include the Router in Your Application","text":"<p>Finally, include the router from the EndpointCreator in your FastAPI application.</p> <pre><code>app.include_router(endpoint_creator.router)\n</code></pre>"},{"location":"usage/endpoint/#advanced-customization","title":"Advanced Customization","text":"<p>You can override the default methods in EndpointCreator for more control over the CRUD operations. You can also specify the operations you want to include. Read more in the advanced section.</p>"},{"location":"usage/endpoint/#conclusion","title":"Conclusion","text":"<p>By following these steps, you can quickly set up CRUD endpoints for your models in a FastAPI application using crud_router or EndpointCreator. This utility function reduces boilerplate code and increases development efficiency by automating the creation of standard API endpoints.</p>"},{"location":"usage/overview/","title":"Usage Overview","text":"<p>The Usage section of our documentation provides comprehensive guides on how to effectively use key features of our application. This section is divided into various topics, each focusing on a specific aspect of usage, ensuring that you have all the information you need to leverage the full potential of our tools and functionalities.</p>"},{"location":"usage/overview/#key-topics","title":"Key Topics","text":""},{"location":"usage/overview/#1-automatic-endpoint-creation-with-crud_router","title":"1. Automatic Endpoint Creation with crud_router","text":"<p>This guide covers the use of <code>crud_router</code> for automatic endpoint creation in FastAPI applications. It provides a step-by-step approach to streamline the creation of standard CRUD endpoints.</p> <ul> <li>Automatic Endpoint Creation Guide</li> </ul>"},{"location":"usage/overview/#2-enhanced-crud-operations-with-fastcrud","title":"2. Enhanced CRUD Operations with FastCRUD","text":"<p>Learn how to use the <code>FastCRUD</code> class for enhanced CRUD operations. This guide delves into the functionalities offered by <code>FastCRUD</code>, including advanced query capabilities, pagination, and error handling.</p> <ul> <li>FastCRUD Usage Guide</li> </ul>"},{"location":"usage/overview/#getting-started","title":"Getting Started","text":"<p>To make the most out of these guides, we recommend familiarizing yourself with FastAPI and SQLAlchemy basics, as our application leverages these frameworks extensively.</p>"},{"location":"usage/overview/#contribution","title":"Contribution","text":"<p>If you have suggestions or contributions to these guides, please refer to our Contributing Guidelines. We appreciate your input in improving our documentation.</p>"}]}